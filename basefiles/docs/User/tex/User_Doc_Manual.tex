\documentclass[titlepage]{article}
\author{Craig Walker}
\title{CCU-LANL Batsim User Doc Manual}
%stix did not work, we use ifsym instead
\usepackage{savesym}
\usepackage{amsmath,amssymb,amsfonts}
\savesymbol{Cross} % Cross is already defined somewhere, probably amsmath,amssymb,amsfonts,
                   % so what we do is save the symbol and restore it as CCUCross
\usepackage[geometry]{ifsym} %\FilledCircle \FilledSmallSquare \SmallCircle
\restoresymbol{CCU}{Cross}
\usepackage{oplotsymbl} %\triangleprfillhl \rhombusfill
\usepackage{helvet}
\usepackage{fontspec}
\usepackage{fontawesome} %\faCircle %\faSquare
\usepackage{listings}
\usepackage{soul}
\usepackage{xparse}
\usepackage{fvextra}
\usepackage{sourcesanspro}
\usepackage{enumitem}



%\usepackage{xunicode}
\usepackage{xltxtra}
\usepackage{xcolor}
\usepackage{array}
\usepackage{hhline}
\usepackage[bookmarks,bookmarksopen,bookmarksdepth=5,colorlinks=true]{hyperref}
\usepackage{bookmark}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue}
\usepackage{polyglossia}
\usepackage[most]{tcolorbox}
\usepackage[margin=0.5in]{geometry}
%\usepackage{lstlinebgrd}   <--  Adding this makes latex flavors not able to find the next package 'sectsty' ??
\usepackage{sectsty}
\usepackage{titlesec}
\usepackage{fancyvrb,newverbs,xcolor}
\setdefaultlanguage[variant=american]{english}
% Text styles
\definecolor{hi-light-yellow}{HTML}{FFFF6D}
\definecolor{hi-light-orange}{HTML}{FFE994}
\definecolor{hi-light-pink}{HTML}{FFD8CE}
\definecolor{hi-light-purple}{HTML}{E0C2CD}
\definecolor{hi-light-green}{HTML}{E8F2A1}
\definecolor{hi-yellow}{HTML}{FFFF00}
\definecolor{lightest-gray}{gray}{.97}
\definecolor{codelist}{RGB}{250, 238, 197}
\colorlet{codelist-light}{codelist!50}
\colorlet{terminal-light}{black!15}
\definecolor{code-blue}{RGB}{4, 86, 194}%{89,131,176}
\definecolor{easter-blue}{RGB}{0,200,255}
\definecolor{myLightBlue}{RGB}{0,100,255}
\colorlet{lightest-blue}{easter-blue!10}
\colorlet{explanation-code}{myLightBlue!23}
\definecolor{comment-greenish}{RGB}{99, 138, 133}
\definecolor{rprompt-color}{RGB}{230,80,120}
\definecolor{prompt-color}{RGB}{160,90,250}
\definecolor{code-keyword}{HTML}{B21354}
\definecolor{code-string}{HTML}{AF770A}
\definecolor{warning-color}{RGB}{255,100,100}
\definecolor{info-color}{RGB}{255,255,255}
\definecolor{important-color}{RGB}{250, 218, 102}
\definecolor{property-teal}{RGB}{22,130,103}
\definecolor{myTerminalRed}{RGB}{160, 60, 73}
\definecolor{myExplanationRed}{RGB}{160,40,100}
\definecolor{argument-color}{RGB}{230,60,73}

% New Commands
\let\oldsection\section
\newcommand\spsection{\oldsection} % same page section
\renewcommand\section{\clearpage\oldsection}
\makeatletter
\titleformat*{\section}{\LARGE\bfseries}
\titleformat*{\subsection}{\Large\bfseries}
\titleformat*{\subsubsection}{\large\bfseries}
\titleformat*{\paragraph}{\normalsize\bfseries}
\titleformat*{\subparagraph}{\small\bfseries}
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}{-3.25ex \@plus1ex \@minus.2ex}{10pt}{\sffamily\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{4}{\z@}{-3.25ex \@plus1ex \@minus.2ex}{10pt}{\sffamily\small\bfseries}}
%\definecolor{explanation-code}{RGB}{50,150,255}

\newenvironment{expverbatim}
 {\SaveVerbatim{cverb}}
 {\endSaveVerbatim
  \flushleft\fboxrule=0pt\fboxsep=.5em
  \colorbox{explanation-code}{%
    \makebox[\dimexpr\linewidth-2\fboxsep][l]{\BUseVerbatim{cverb}}%
  }
  \endflushleft
}
% types of explanation boxes
\newcommand\infoC{\faInfoCircle}
\newcommand\alertC{\faExclamationCircle}
\newcommand\alertT{\faExclamationTriangle}
%
\AfterEndEnvironment{explanation}{\color{black}}
\AfterEndEnvironment{itemize}{\color{black}}
\AfterEndEnvironment{enumerate}{\color{black}}
\AfterEndEnvironment{description}{\color{black}}

%\renewcommand{\familydefault}{\sfdefault}
\newenvironment{regular}{\color{black}\linespread{1.2}\selectfont}{}
\usepackage{marvosym}


%-------------------------------------------------------------------
%                            Background Color Ranges
%-------------------------------------------------------------------
\usepackage{pgf}
\usepackage{pgffor}

\makeatother
\newcommand\myIfRange[3]{%
\ifnum\value{lstnumber}>\numexpr#1-1\relax
	\ifnum\value{lstnumber}<\numexpr#2+1\relax
		\color{#3}
	\fi
\fi}
\newcommand\myIf[2]{%
\ifnum\value{lstnumber}=#1
	\color{#2}
\fi}
\newcommand\myStart{\color{lightest-gray}}
\newcommand\myTitle{What This Code Does}
					
					
%--------------------------------------------------------------------

%--------------------------------------------------------------------
% these tcblistings use xparse for the arguments.  read the documentation for that if unsure of syntax.  O is optional m=mandatory
\tcbuselibrary{xparse,minted}   %minted is for highlighting code.  styles didn't work for me, but languages do.
% all styles
% manni rrt perldoc borland colorful murphy vs trac tango fruity autumn 
% bw emacs vim pastie friendly native monokai
\usemintedstyle[Bash]{tango}
\usemintedstyle[C++]{trac}
\usemintedstyle[python]{manni}
%Acceptable styles
%Bash
%murphy%tango%autumn%emacs%pastie
%C++
%colorful%trac%autumn%pastie
%python
%manni%murphy%autumn%pastie

%this is for writing bash code and escaping commands.  bash language in pygmentize (which minted uses) does not like backslashes, thinks of them as strings
%so we escape (unfortunately minted only uses 1 char for setting escapeinside in tcb environment)
%and then we do {?{color}{red}hello}.  So if ++ is escapeinside then + ?{color}{red}?{small}hello + 
\catcode`\?=\active
\gdef?#1{\csname #1\endcsname}
\catcode`\?=12

% a prompt for the terminal
\def\rprompt{\color{rprompt-color}\textbf{root >}\hspace{3mm}} %root prompt
\def\prompt{\color{prompt-color}\textbf{user >}\hspace{3mm}}   %user prompt
% \begin{termESC}   terminal block that allows ++ escaping.  Use +?{command}+
% \begin{hicode}[language] Use for highlighted code in the language it is.
% \begin{explanation}
% \begin{important}
% \begin{warning}
% \lstTerm{terminal command}
% \lstFolder{folder/path}
% \lstCode{Code statement}

\renewcommand{\theFancyVerbLine}{\sffamily
\textcolor[rgb]{0.5,0.5,1.0}{\small
\oldstylenums{\arabic{FancyVerbLine}}\hspace{2mm}}}
\newcommand\tildesign{~}
\NewTCBListing{hicode}{ !O{python} !O{ } }{%
  breakable,
  left=15mm,
  before skip=5mm,
  after skip=10mm,
  colback=codelist!50,
  colframe=codelist!50,
  arc=3pt,
  boxrule=0pt,  
  listing only,
  listing engine=minted,
  minted language=#1,
  minted options={numbers=left,tabsize=1,fontsize=\small,escapeinside=~~,#2}
}
\NewTCBListing{code}{ !O{python} !O{ } }{%
  breakable,
  left=10mm,
  colback=codelist!50,
  colframe=codelist!50,
  arc=3pt,
  boxrule=0pt,  
  listing only,
  listing engine=listings,
  listing options={language=#1,stringstyle=\ttfamily,commentstyle=\itshape\bfseries\color{comment-greenish},keywordstyle=\color{code-keyword}\bfseries,showstringspaces=false,numbers=left,style=CODE-STYLE,tabsize=1,#2}
}
\newcommand\plussign{+}
\NewTCBListing{hiterminal}{ !O{} }{%
  breakable,
  top=2mm,
  bottom=2mm,
  left=15mm,
  before skip=5mm,
  after skip=10mm,
  colback=black!15,
  colframe=black!15,
  arc=5pt,
  listing engine=minted,
  minted language=Bash,
  boxrule=0pt,
  listing only,
  minted options={breaklines=true,numbers=left,tabsize=1,fontsize=\small,escapeinside=++,baselinestretch=1.3,#1}
}
\newcommand\notsign{!}
\NewTCBListing{Phiterminal}{ !O{} }{%
  breakable,
  top=2mm,
  bottom=2mm,
  left=15mm,
  before skip=5mm,
  after skip=10mm,
  colback=black!15,
  colframe=black!15,
  arc=5pt,
  minted language=text,
  listing engine=minted,
  boxrule=0pt,
  listing only,
  minted options={breaklines=true,numbers=left,tabsize=1,fontsize=\small,escapeinside=!!,baselinestretch=1.3,#1}
}
\newcommand\atpipesign{@|}
\NewTCBListing{terminal}{ !O{style=TERMINAL} }{%
  top=-1mm,
  bottom=-1mm,
  before skip=10pt,
  after skip=10pt,
  colback=black!15,
  colframe=black!15,
  arc=5pt,
  listing engine=listings,
  boxrule=0pt,
  listing only,
  listing options={tabsize=1,language=Bash,escapechar=@|,commentstyle=\itshape\bfseries\color{comment-greenish},#1}
}
\NewTCBListing{explanation}{ O{style=EXPLANATION-STYLE} m}{%
	enhanced,
  before skip=5mm,
  after skip=10mm,
	colback=myLightBlue!30,
	colframe=myLightBlue!30!black!90,
	coltitle=lightest-blue!50,
	fonttitle={\fontsize{15}{25}\bfseries},
	listing only,
	breakable,
	arc=5pt,
	title={\Large{\textcolor{info-color}{\infoC}} \quad #2},
	listing options={showstringspaces=false,showtabs=false,escapechar=@|,#1}
}
\NewTCBListing{important}{ O{style=EXPLANATION-STYLE} m}{%
	enhanced,
  before skip=5mm,
  after skip=10mm,
	colback=myLightBlue!30,
	colframe=myLightBlue!30!black!90,
	coltitle=lightest-blue!50,
	fonttitle={\fontsize{15}{25}\bfseries},
	listing only,
	breakable,
	arc=5pt,
	title={\Large{\textcolor{important-color}{\alertC}} \quad #2},
	listing options={showstringspaces=false,showtabs=false,escapechar=@|,#1}
}
\NewTCBListing{warning}{ O{style=EXPLANATION-STYLE} m}{%
	enhanced,
  before skip=5mm,
  after skip=10mm,
	colback=myLightBlue!30,
	colframe=myLightBlue!30!black!90,
	coltitle=lightest-blue!50,
	fonttitle={\fontsize{15}{25}\bfseries},
	listing only,
	breakable,
	arc=5pt,
	title={\Large{\textcolor{warning-color}{\alertT}} \quad #2},
	listing options={showstringspaces=false,showtabs=false,escapechar=@|,#1}
}
\setlength\parindent{0pt}
\setlength\parskip{10pt}
\setcounter{tocdepth}{5} 
\setcounter{secnumdepth}{5}

\setmonofont{DejaVu Sans Mono}

% so detokenize is nice for a listing, it takes any special meaning off of things like #,$,\
% the problem is that it has problems with # as this is what is used for an argument
% it ends up doubling it.  Some commands will double the # and some half them.  But we want a 
%single # in our document so this will use Latex3 to take all control sequences with parameter code (#) and replace with the string version of #
%N=command, p=parameter list, n=token list, x=expanded token list
\ExplSyntaxOn

\def\mystrut{\rule[\dimexpr-1.2\dp\strutbox+\fboxsep]{0pt}{%
 \dimexpr\normalbaselineskip-1\fboxsep}}
\def\grayspace{\hspace{0pt minus \fboxsep}}
\NewDocumentCommand{\lstTerm}{ v }{
  \ \allowbreak\sloppy\grayspace\tcbox[breakable,on~line,boxsep=3pt, left=0pt,right=0pt,top=0pt,bottom=0pt,colframe=white,colback=black!15]{\textcolor{myTerminalRed}{\small\ttfamily\mystrut\smash{#1}}\ 
}}
\NewDocumentCommand{\lstFolder}{ v }{
  \ \allowbreak\sloppy\grayspace\tcbox[breakable,on~line,boxsep=3pt, left=0pt,right=0pt,top=0pt,bottom=0pt,colframe=white,colback=black!15]{\textcolor{blue!70}{\small\ttfamily\mystrut\smash{#1}}\ 
}}
%\NewDocumentCommand{\lstCode}{ v }{
%  \ \allowbreak\sloppy\grayspace\colorbox{codelist!90}{\textcolor{code-blue}{\small\ttfamily\mystrut\smash~{#1}}\ 
%}}
\NewDocumentCommand{\lstCode}{ v }{
  \ \allowbreak\sloppy\grayspace\tcbox[tcbox~width=auto~limited,breakable,on~line,boxsep=3pt, left=0pt,right=0pt,top=0pt,bottom=0pt,colframe=white,colback=codelist!90]{\textcolor{code-blue}{\small\ttfamily\mystrut\smash~{#1}}\ 
}}
\NewDocumentCommand{\lstProperty}{ v }{
  \ \allowbreak\sloppy\grayspace\tcbox[tcbox~width=auto~limited,breakable,on~line,boxsep=3pt, left=0pt,right=0pt,top=0pt,bottom=0pt,colframe=white,colback=black!15]{\textcolor{property-teal}{\small\ttfamily{#1}}\ 
}}
\NewDocumentCommand{\lstArg}{ v }{
  \ \allowbreak\sloppy\grayspace\tcbox[tcbox~width=auto~limited,breakable,on~line,boxsep=3pt, left=0pt,right=0pt,top=0pt,bottom=0pt,colframe=white,colback=black!15]{\textcolor{argument-color}{\small\ttfamily\mystrut\smash{#1}}\ 
}}
\NewDocumentCommand{\Opt}{ m }{\textbf{\textit{#1}}}
%this \Detokenize function is just to play with.  It answers some questions I had
%about latex3,regex, catcodes, etc..
%it can go around #1 in \lstCode
%Note that this stuff didn't work too well before I set the variable to verbatim
%  you can see how I was calling it before in \mytokens below
% right now it replaces all (P)arameter catcoded(6)of any character with a #(11)
% it then replaces a {(11) with {(1) and }(11) with }(2)
% I believe that you must switch both the { and the } to (1/2)(B/E) at the same time or else
% you will have an unbalanced expression
% all code 11's above may be code 12.  Not sure right now.
%
\cs_new:Npn \Detokenize #1 {
  %\cs_set_eq:NN \myDetokenize:n \detokenize

  \tl_clear_new:N \l_ccu_ourInput
  \tl_set:Nn \l_ccu_ourInput {#1}
  \regex_replace_all:nnN { \cP. }{ \# } \l_ccu_ourInput
  \regex_replace_all:nnN { \{ (.*) \} }{ \cB\{ \1 \cE\} } \l_ccu_ourInput
  \regex_replace_all:nnN { \cE. }{ m \cE\} } \l_ccu_ourInput
  \tl_to_str:V {\l_ccu_ourInput}
  %\tl_to_str:o {\ourInput}
}
\ExplSyntaxOff

\makeatletter

\newcommand\mytokens[3]{\mytokenshelp{#1}{#2}#3 \relax\relax}
\def\mytokenshelp#1#2#3 #4\relax{\allowbreak\sloppy\grayspace\tokenscolor{#1}{#2}{#3}\ifx\relax#4\else
 \mytokenshelp{#1}{#2}#4\relax\fi}
\newcommand\tokenscolor[3]{\colorbox{#1}{\textcolor{#2}{%
  \small\ttfamily\mystrut\smash{\Detokenize{#3}}}}}
%\newcommand{\lstTerm}[1]{a}

%\newcommand{\lstTerm}[1]{~~\mytokens{black!15}{myTerminalRed}{#1}~}
%\newcommand{\lstFolder}[1]{~~\lstfolder{black!15}{blue!70}{#1}~}
%\newcommand{\lstFolder}[1]{a}
%\newcommand{\lstCode}[1]{a}
%\newcommand{\lstfolder}[1]{~~\mytokens{black!15}{blue!70}{#1}~}
%\newcommand{\lstCode}[1]{~~\mytokens{codelist!90}{code-blue}{#1}~}

%\NewDocumentCommand{\lstCode}{v}{\sethlcolor{codelist-light}\texthl{\Verb{#1}}}
%\newcommand{\lstCode}[1]{\hl{\Verb#1}}
%\soulregister\lstCode1
%\newcommand{\lstCode}[1]{%
%  \edef\hverb@tmp{#1}%
%  \expandafter\hl\expandafter{\hverb@tmp}}
\makeatother
\newenvironment{termESC}{\catcode`\?=\active \hiterminal}{\endhiterminal}
%termP{lain}ESC
\newenvironment{termPESC}{\catcode`\?=\active \Phiterminal}{\endPhiterminal}
%\setcounter{section}{-1}

\newcommand\subsubsubsection\paragraph
\newcommand\subsubsubsubsection\subparagraph

\begin{document}
\setlistdepth{9}
\setlist[itemize,1]{label=\FilledCircle}
\setlist[itemize,2]{label=\FilledSmallSquare}
\setlist[itemize,3]{label=\SmallCircle}
\setlist[itemize,4]{label=$\rhombusfill$}
\setlist[itemize,5]{label=$\diamond$}
\setlist[itemize,6]{label=$\star$}
\setlist[itemize,7]{label=$\bullet$}
\setlist[itemize,8]{label=$\square$}
\setlist[itemize,9]{label=$-$}

\renewlist{itemize}{itemize}{9}
\sffamily
\allsectionsfont{}


\lstdefinestyle{EXPLANATION-STYLE}
{
 	columns=flexible,
 	breaklines=true,
    basicstyle={\normalsize\color{black}\sffamily}
}
\lstdefinestyle{TERMINAL}
{
 	columns=fullflexible,
 	breaklines=true,
  escapechar=@|,
	backgroundcolor=\color{black!15},
    basicstyle=\small\ttfamily
}
\lstdefinestyle{TERMINAL-FLEX}
{
 	columns=flexible,
 	breaklines=true,
	backgroundcolor=\color{black!15},
    basicstyle=\small\color{myTerminalRed}\ttfamily
}
\lstdefinestyle{CODE-STYLE}
{
	columns=flexible,
	breaklines=true,
	escapechar=@|,
	backgroundcolor=\color{codelist!50},
    basicstyle=\small\ttfamily
}


\maketitle
\hypersetup{linkcolor=blue,urlcolor=blue,anchorcolor=blue}

\pdfbookmark[section]{Table Of Contents}{1}
\tableofcontents
\pagebreak
\phantomsection \addcontentsline{toc}{section}{i. Preface}
\section*{i. Preface}


\begin{regular}

  This manual serves to be a definitive guide, for the user, to our CCU-LANL additions to the Batsim/Batsched simulator.
  If you need a guided tour through the CCU-LANL additions, make sure to read \textbf{\textit{ User\_Doc\_Walkthrough.pdf}}.


  As the user guide, this document will explain all options and cover different scenarios.  This guide will \emph{not} cover
  how to code for additions to the simulator, however.  If one desires this (such as adding another scheduling algorithm, 
  adding another option to Batsim, or adding sweeps) please look to our \textbf{\textit{Developer\_Doc\_Manual.pdf}}.
  It may still be advisable to read this document and/or \textbf{\textit{ User\_Doc\_Walkthrough.pdf}} to get a sense of
  Batsim before you start changing the code.

  It is our hope that our additions to Batsim can serve the community well, and that this guide will explain things
  as clearly as we hope.  Good luck with all things Batsim, and all things HPC.

\end{regular}
\phantomsection \addcontentsline{toc}{section}{ii. Style Of Document}
\subsection*{\LARGE ii. Style Of Document}
\begin{regular}
There is a certain style to this guide that should be made apparent.
\end{regular}
\begin{itemize}
  \vspace{3mm}
  \item \textbf{Inline style:}
  \vspace{3mm}
        \begin{enumerate}
          \item \lstTerm{Commands you would run ./from --the --terminal --look --like --this.}
          \item \lstArg{Just an --argument to a command will look like this.}
          \item \lstProperty{A config 'property': will look like this}
          \item \lstFolder{A/folder/or/file/path/would/look/like/this.}
          \item \lstCode{Code::would #look like() this.}
         \end{enumerate}
  \vspace{7mm}
  \item \textbf{Block style:}
  \vspace{3mm}
        \begin{enumerate}
          \item \textbf{Terminal}
\begin{termESC}
+?{prompt}+#this is a terminal block, and this is a comment in it.
+?{prompt}+./and_this_would_be_a_command & | if [[ ]] ; for ;do echo 
+?{prompt}+cd ~/our/path # and this is a known command
+?{prompt}+su -
Password:
+?{rprompt}+./this_would_run_as_root
\end{termESC}
          \item \textbf{Code}
\begin{hicode}[C++]
//A c++ code block looks like this, and this is a c/c++ comment in it
and this::is::a::function()
{
  with an int definition;
  int a=10;
  string name="CCU-LANL";
  return 10;
}
\end{hicode}
\begin{hicode}[python]
# and this is python code
import pandas as pd
with open("file.csv","r") as InFile:
  df = pd.read_csv(InFile,sep=",")
def hello:
  print("world")
  q = [ 5,10 ]
\end{hicode}
          \item \textbf{Explanations}
          
          \begin{enumerate}
            
            \item \textbf{Additional Info}
            \begin{explanation}{Explains Some Additional Info}
            Additional info here
            \end{explanation}
            
            \item \textbf{Important Info}
            \begin{important}{Explains Important Info}
            This is very important
            \end{important}
            
            \item \textbf{Warning Info}
            \begin{warning}{Info That Warns You}
            This will certainly break the internet
            \end{warning}
          
          \end{enumerate}
        
        \end{enumerate}

\end{itemize}


\section{Intro}
\begin{regular}
There are a couple things to define right now so it is easier to communicate.\\

These are things we wish to define:
\begin{enumerate}
  \item \hyperlink{intro_batsim}{How Batsim Works}
  \item \hyperlink{intro_framework}{How Our FrameWork Works}
  \item \hyperlink{intro_folders}{Our Folder Structure}
  \item \hyperlink{intro_analysis}{How Our Analysis Works}
\end{enumerate}
\end{regular}

\hypertarget{intro_batsim}{}
\subsection{How Batsim Works}
\begin{regular}
 Batsim uses 4 main tools:
 \begin{enumerate}
  \item \textbf{Simgrid}
        \begin{itemize}
          \item This is what runs under the hood, simulating the passage of time and the running of jobs, as well as the cluster layout (taken from a platform xml file).
        \end{itemize}
  \item \textbf{Batsim}
        \begin{itemize}
          \item This is what takes most of our options, reads in our workload, and tracks the progress of jobs.  
                It stays in communication with Batsched through events that are sent over a messaging system (using a socket).
                That means if no events are happening and the last call to Batsched had finished, then Batsched is not being run.
        \end{itemize}
  \item \textbf{Batsched}
        \begin{itemize}
          \item This is what is responsible for making scheduler decisions.  It is alerted when a job is submitted, killed, and completed (along with some other notification alerts).
                But the main thing it decides is when a job starts and what machines to start it on.  There are several algorithms to choose from for the scheduler.
        \end{itemize}
  \item \textbf{Robin}
        \begin{itemize}
          \item Batsim is tied to the Simgrid library and runs as one process.  Batsched runs as another process.
                Robin is a nice tool that bridges these two processes together as its own process and tracks the progress of Batsim and Batsched. 
        \end{itemize}
 \end{enumerate}
 So from these 4 tools there are 3 processes that run during one simulation: batsim, batsched, and robin.  Note that all 3 of the tools are lowercase executables.
\end{regular}

\hypertarget{intro_framework}{}
\subsection{How Our FrameWork Works}
\begin{regular}
Our Framework is made to setup and run simulations, and then post-process after the simulation ends.
Most of the work to this framework has gone into the setting up and running of the simulations.  
It relies on a single json config file that the user makes, as well as some additional options sent to the tool \lstTerm{myBatchTasks.sh}. This tool sets up your experiment's
folder structure and options being sent to each simulation.  It can be run on a single machine or a cluster.
\subsubsection{The Config File}
Without going into too much detail yet, the config file has 4 main parts to it:
\end{regular}
\begin{enumerate}
  \item \textbf{Sweeps}
        \begin{itemize}
          \item These allow you to do a parameter range (or sweep) over certain values.  Each sweep is a little different in its syntax.
                Each value that is generated as a parameter to an option represents a new experiment.  If multiple sweeps are used the amount of experiments produced get multiplied.
                So 2 options generated by one sweep, then 3 options generated by another sweep would mean 6 experiments would be generated.
        \end{itemize}
  \item \textbf{Individual options}
        \begin{itemize}
          \item These are just regular options added to each experiment.
        \end{itemize}
  \item \textbf{Workload options}
        \begin{itemize}
          \item These are options to either a ``grizzly-cluster-like'' workload or a synthetic workload.  When random numbers are used
                they can generate a subset of experiments we've called ``id''s (as each workload generated has a unique ID) and their simulation's output are put into their own ``id'' folder under the experiment folder.
        \end{itemize}
  \item \textbf{Output options}
        \begin{itemize}
          \item There are only a couple options as to what output you want.  But the main option has to do with how many ``runs'' to do for each experiment.  Given the random
                nature some options give to the simulation itself, it is advisable to run many ``runs'' per experiment when this is the case.  Then you can use tools to average them. 
                400 runs should give you an idea of what is happening. 1000 or 1500 runs has seemed to be good for papers we have written.
        \end{itemize}
\end{enumerate}
\subsubsection{myBatchTasks.sh}
Our Framework relies on the command-line (for now), and so there are tools to make this easier.  As mentioned, the main tool you will use is
\lstTerm{myBatchTasks.sh}.  What you will do is:
\begin{enumerate}
  \item write your config file
  \item point \lstTerm{myBatchTasks.sh} to this file
  \item tell \lstTerm{myBatchTasks.sh} what kind of parallelization you want/need
  \item run \lstTerm{myBatchTasks.sh}.  This will:
    \begin{enumerate}
      \item create a workload and platform for each simulation (When needed. Workloads and platforms get reused if they can be reused)
      \item set up the folder for each simulation
      \item write the options each simulation gets inside its folders
      \item depending on the parallelization will:
      \begin{itemize}
        \item run each simulation in turn \textbf{(parallelization: none)}
        \item run batches of simulations by backgrounding them \textbf{(parallelization: background)}
        \item run sbatch on every simulation \textbf{(parallelization: sbatch)}
        \item run sbatch on batches of simulations and run those simulations as tasks \textbf{(parallelization: tasks)}
      \end{itemize}
      \item In the case of parallelization: 
      \begin{itemize}
        \item \textbf{none | background}, \lstTerm{myBatchTasks.sh} will continue to run to completion
        \item \textbf{sbatch | tasks}, \lstTerm{myBatchTasks.sh} will stop after handing over the jobs to SLURM
      \end{itemize}
      \item The simulations will start and after finishing, will run \lstTerm{post-processing.py} to post-process.
    \end{enumerate}
\end{enumerate}
\hypertarget{intro_folders}{}
\subsection{Our Folder Structure}
\begin{regular}
Our folder structure has been a work in progress, so it may seem a little chaotic.  Hopefully after explaining it,
it will make sense to you.

\vspace{3mm}

There are 2 main folders in our FrameWork:
\end{regular}
\begin{enumerate}
  \item The \textbf{Simulator Folder}
  \begin{itemize}
    \item This folder is basically your default location.
    \item Holds a \lstFolder{configs} folder for your config files.
    \item Holds an \lstFolder{experiments} folder for your projects.
    \item Holds \lstFolder{basefiles} folder:
    \begin{itemize}
      \item Holds all the scripts for deploying batsim, running simulations, processing simulations, and analysis.
      \item Holds the \lstFolder{workloads} folder where workloads are kept.
    \end{itemize}
  \end{itemize}
  \item The \textbf{Project Folder}
  \begin{itemize}
    \item This folder is where a project resides.
    \item This is normally in the \lstFolder{simulator/experiments} folder, but can be located anywhere.
  \end{itemize}
\end{enumerate}
\subsubsection{'Project Folder'/}
The Project Folder is where all your simulations will end up.  This can be named anything and put anywhere.  Consider the I/O requirements of your simulations and make sure that the drives you choose to store things on are up to the task.  Each simulation writes out to I/O for each simulated job that completes, and the chosen options of your logging (it is highly recommended you turn logging off on 'real' simulations...ie ones that aren't just tests).  So, drives that are somewhat responsive are important.

\subsubsection{'Experiment Folder'/}
In your json config file you can set options for a set of jobs known as an "Experiment".  You must supply at least one Experiment, but you may choose to include more than 1 Experiment in your config file.  Each Experiment can be named anything you want, but something descriptive is helpful.  Also each Experiment name must be unique for each Project.

So to summarize, a place to store your project is chosen with the name of the Project Folder tacked on.  Then the config file is read, and each first-level json key that includes an \lstCode{ "input":{ } } and \lstCode{ "output":{ } } section will be made into an 'Experiment Folder' in your \lstFolder{.../'Project Folder'}.
\subsubsection{experiment\_\#/}
\begin{regular}
When given the minimum required options, \lstTerm{myBatchTasks.sh} will start by running a setup script.
This setup script will read in your config file and generate the project's experiment(s), one for each first level json key.
Within each first level json key is an \lstProperty{'input'} key and an \lstProperty{'output'} key.  The options, including the sweeps, will generate a job
for each set of unique options.  These jobs are labeled \lstFolder{experiment_#} where \# is an integer, and reside under the \lstFolder{.../'Project Folder'/'Experiment Folder'/} folder.

In a future release we want to change these folder's names to \lstFolder{job_#} to make the naming clearer, or maybe even \lstFolder{options_#} to differentiate them when
talking about SLURM 'jobs'.  But for now, there are 'project's experiment(s)', and there are jobs within the 'project experiment' named \lstFolder{experiment_#}.
\end{regular}

\subsubsection{id\_\#/}
\begin{regular}
Under each job folder is an \lstFolder{id_#} folder.  This represents the workload \lstProperty{ 'index':<int> } that was used.  An index on workloads helps make them
unique.  Sometimes you want to roll the dice on the randomness again when a workload is created.  A unique index with the other options will
force the creation of a workload because a workload is created when no other options match it, the index being one of them.  So will \lstProperty{ 'force-creation':true } but an index can be referenced again later if you want to reuse that workload, as long as all the other options remain the same and the database hasn't been deleted.
Also, \lstProperty{ 'workload-ids':<str> } can set multiple indices for a single 'project experiment', putting each index in its own \lstFolder{id_#} folder.  This is how you would do some kind of statistical analysis on the workload options.
\end{regular}

\subsubsection{Run\_\#/}
\begin{regular}
Under each \lstFolder{id_#} folder are \lstFolder{Run_#} folders.  Instead of creating a bunch of new workloads for statistical analysis (like in id's), this represents a single workload for all Runs.  However, certain options to Batsim will cause randomness (failures).  To do statistical analysis for these situations we use multiple 'runs'.  The amount of runs for a certain 'project experiment' can be set in the \lstCode{'output':{ } } section.  We have called the option \lstProperty{'avg-makespan':<int>} for historical reasons.  Set that to how many runs you would like for each id and for every job.  This adds up quickly.  If a 'project experiment' has 3 jobs and we did 10 indices with \lstProperty{ 'workload-ids':<str> } option, and then we did 20 runs with the \lstProperty{ 'avg-makespan':<int> } option, that would equate to 3 * 10 * 20 = 600 simulations and 10 workloads being created (provided they were unique indices for those workload options).
\end{regular}

\subsubsection{input/ and output/}
\begin{regular}
After \lstFolder{Run_#} there are two folders made: \lstFolder{input} and \lstFolder{output}.  \lstFolder{input} gets the \lstFolder{config.ini} for the simulation options.  Before running a simulation, this \lstFolder{config.ini} helps make the \lstFolder{experiment.yaml} file that \lstTerm{robin} creates and reads.

In a future release of Batsim we may move the workload creation into Batsim itself.  Currently it remains part of the setup before launching the simulations.

After the setup script is completed it will enter the \lstTerm{run-experiments.py} phase.  Each 'project experiment' is traversed and each \lstFolder{project/experiment/experiment_#/id_#/Run_#} will be submitted as a simulation.  If done locally, \lstTerm{run-experiments.py} will continue until all of the simulations finish.  If done using SLURM, \lstTerm{run-experiments.py} passes all of these simulations over to SLURM and the nodes will run their simulations.

Simulations are started in the \lstTerm{real_start.py} script.  \lstTerm{robin} is invoked in this script and generates the appropriate \lstFolder{ .../Run_#/input/experiment.yaml} file from the \lstFolder{.../Run_#/input/config.ini}.  \lstTerm{robin} is invoked again to run the simulation from the yaml file.  Once the simulation has ended correctly, the \lstFolder{.../Run_#/output/config.ini} is read and the appropriate options are sent over to the \lstTerm{post-processing.py} script.  Finally, the \lstFolder{.../Run_#/output/progress.log} file is updated with \lstCode{ { "completed":true } }

SLURM puts the job's log info in \lstFolder{.../Run_#/output/slurm-#.out}.  Simulations, on the other hand, put their output in \lstFolder{.../Run_#/output/expe-out}, mainly \lstFolder{.../expe-out/out_jobs.csv} and \lstFolder{.../expe-out/out_extra_info.csv}.  Batsim log info goes to \lstFolder{.../expe-out/log/batsim.log} and Batsched log info goes to \lstFolder{.../expe-out/log/sched.err.log}

\end{regular}
\subsubsection{Real Checkpointing: checkpoint\_\#/ and expe-out\_\#/ }
\subsubsubsection{Real Batsim Checkpointing Options To Write Out Checkpoint}
\begin{regular}
Checkpointing Batsim is a recent feature added where Batsim is able to do in real life what it also simulates in the simulation, checkpointing its state so it can start from that point in the simulation later.  There are three (3) options for this to happen:
\begin{itemize}
  \item \lstProperty{'checkpoint-batsim-interval'}
    \begin{itemize}
       \item Will set an interval to do real checkpoints
       \begin{itemize}
          \item syntax: <string>
          \begin{itemize}[label=$\rhombusfill$]
            \item <string> syntax: \verb'"(real|simulated)[:once]:days-HH:MM:SS[:keep]"'
            \begin{itemize}[label=\diamond]
              \item 'real' prepended will interpret the interval to be in real time
              \item 'simulated' prepended will interpret the interval to be in simulated time 
              \item 'optional :once will do one checkpoint and then stop doing any more checkpoints
              \item days-HH:MM:SS is simply days followed by a '-' followed by hours:days:seconds.
              \begin{itemize}
                \item days is simply multiplied by 3600*24, hours by 3600, and minutes by 60
                \item days, hours, minutes, and seconds can actually be as many digits as you want greater than 0 digits.
                \item This means the time can be completely in seconds, or minutes, or hours, or days
                \item examples: '0-0:0:537' or '3-00:00:00' or '1-12:30:00'
              \end{itemize}
              \item optional :keep will set the amount of checkpoints to keep.  \lstProperty
              {'checkpoint-batsim-keep'} trumps this.
            \end{itemize}
          \end{itemize}
        \end{itemize}
      \end{itemize}
      \item \lstProperty{'checkpoint-batsim-keep'}
  \begin{itemize}
    \item How many checkpoints to keep.  default: 1
    \begin{itemize}
      \item syntax: <int>
    \end{itemize}
  \end{itemize}
  \item \lstProperty{'checkpoint-batsim-signal'}
  \begin{itemize}
    \item The signal number to use for signal driven checkpointing.  SLURM can send a signal to checkpoint to the process before the job's wallclock-limit is reached.  see SBATCH\_SIGNAL in SLURM docs.
    \begin{itemize}
      \item syntax: <int>
        \begin{itemize}
          \item <int> syntax:
          \begin{itemize}
            \item You will want to either use SIGUSR1(10), SIGUSR2 (12), or preferably real-time signals from 35-64
          \end{itemize}
        \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}
\end{regular}
\subsubsubsection{How Checkpoints Are Written, checkpoint\_\#/}
The reason we include Real Checkpointing in the 'Folder Structure' section is to illustrate the folders that are made using this feature.

When a real checkpoint is written out, it will put the checkpoint in \lstFolder{.../Run_#/output/expe-out/checkpoint_1/}.  There will also be a symbolic link created to this folder \lstFolder{.../Run_#/output/expe-out/checkpoint_latest}.  

If another checkpoint is written out, what happens depends on whether you have chosen to 'keep' any checkpoints or not.  This is set in either \lstProperty{'checkpoint-batsim-interval'} or \lstProperty{'checkpoint-batsim-keep'}.  The default is 1 and should not be less than 1.  If it is set to 1, then the next checkpoint simply overwrites the \lstFolder{.../expe-out/checkpoint_1/} folder.  

If 2 is set to be kept then \lstFolder{.../expe-out/checkpoint_1/} is moved to \lstFolder{.../expe-out/checkpoint_2/}, and the current checkpoint is written to \lstFolder{.../expe-out/checkpoint_1/}.  \lstFolder{.../expe-out/checkpoint_latest} always points to \lstFolder{.../expe-out/checkpoint_1/}. If another checkpoint is written then \lstFolder{.../expe-out/checkpoint_2/} is deleted and \lstFolder{.../expe-out/checkpoint_1/} moves down to \lstFolder{.../expe-out/checkpoint_2/}, and then the current checkpoint is written to \lstFolder{.../expe-out/checkpoint_1/}.

If 3 is set to be kept, we get a similar behavior as when 2 is kept except that on the 3rd checkpoint, \lstFolder{checkpoint_2/} moves to \lstFolder{checkpoint_3/}. And then on the 4th checkpoint, \lstFolder{checkpoint_3/} is deleted, everything else moves 'down', so \lstFolder{checkpoint_2/} becomes \lstFolder{checkpoint_3/}, \lstFolder{checkpoint_1/} becomes \lstFolder{checkpoint_2/}, and the current checkpoint is, again, written to \lstFolder{checkpoint_1/}.




\subsubsubsection{Starting From A Checkpoint, expe-out\_\#/}
Starting from a checkpoint starts with options to \lstTerm{myBatchTasks.sh}, mainly \lstArg{-S, --start-from-checkpoint <int>}.  Make sure that the number passed corresponds to a checkpoint that actually exists.  Passing a number not corresponding to a checkpoint that exists will result in errors and stop execution of your simulations.  There may be a case when some simulations didn't checkpoint for that iteration, but some did.  In this case you can use the \lstArg{-I,--ignore-does-not-exist} option.  It will run those simulations that have that checkpoint and won't do anything to those that don't have the checkpoint.

The order that things happen is the following: First \lstTerm{generate_config.py} is called with the {--start-from-checkpoint <int>} option and that triggers \lstTerm{generate_config.py} not to read your config script.  Instead it changes all the \lstFolder{.../input/config.ini} files to update what checkpoint they are starting from and other values mentioned below.

Second when a simulation starts from a checkpoint in the \lstTerm{run-experiments.py} phase and later in the \lstTerm{real_start.py} individual simulation script, it will first check that the checkpoint path exists and if it does, then it will move the current \lstFolder{.../output/expe-out} folder to \lstFolder{../output/expe-out_1}.  This is what we call a 'Frame'.  The new simulation always occurs in \lstFolder{.../output/expe-out}.

There is an option to \lstTerm{myBatchTasks.sh}  \lstArg{-K, --start-from-checkpoint-keep <int>}.  This will keep <int> frames.  Every time you start from a checkpoint a new frame is made if that checkpoint path existed.  If you set the \lstArg{-K <int>} option, that many Frames will stay around.  If you set it to 2 and start from a checkpoint 3 times, then one frame will be deleted, much like checkpoints are moved 'down' and off.

To start from a certain frame use the \lstArg{-F, --start-from-frame <int>} option.  In conjunction with \lstArg{-S, --start-from-checkpoint <int>} it will start the simulation at \lstFolder{.../output/expe-out_#A/checkpoint_#B} where \#A is the frame and \#B is the checkpoint. There is also an option \lstArg{-D, --discard-last-frame}.  This will make it like the last frame didn't happen, then will apply all the start options you gave it and run your simulations.

One last option before we move on to other things: \lstArg{-C, --skip-completed-sims}.  This option will check the \lstFolder{.../output/progress.log} for each simulation to see if the simulation had finished.  If it had, then it will skip running it.

\subsubsection{Putting 'Folder Structure' all together}
\includegraphics{./folder_structure.png}


\hypertarget{intro_analysis}{}
\subsection{How Our Analysis Works}
\begin{regular}
As mentioned, the analysis is mostly left up to the user.  There are a couple exceptions.
\subsubsection{aggregate\_makespan.py}
To average and aggregate a folder's \lstFolder{avg_makespan.csv} files you can use this script.
It will output a single \lstFolder{total_makespan.csv} file in the project folder.
It will also output an \lstFolder{errors_total_makespan.csv} file so that you can see what jobs did not complete.
It lists which files it did not find and it has a summary at the bottom.

This file gives an alright example of how to traverse the project folder.
\subsubsection{aggregate\_aggregates.py}
This is used for aggregating multiple \lstFolder{total_makesan.csv} files.  This can be useful if you do a bunch of sims in batches.
\subsubsection{.../tests/analysis.py}
This file goes along with our config file \lstFolder{.../tests/configs/paper.config}.  It has a lot of code in it, but hopefully you can
find something that will pertain to your needs.
\subsubsection{.../tests/application\_efficiency.py}
This file goes along with our config file \lstFolder{.../tests/application_efficiency.config}.
It was one of the first things we used to verify that failures and simulated checkpointing were working.
We hope you can learn something from this simple script, as well.
\end{regular}
\section{Installation/Deployment}

Here you will learn how to deploy the simulator in an environment right for you.

\subsection{Requirements}

Requirements (bare-metal and charliecloud):
\begin{itemize}
  \item linux os
  \item gcc >= 8.0 (bare-metal needs c++17, charliecloud method may allow for previous versions)
  \item cmake >= 3.15.4  (maybe previous versions. at least 3.11)
  \item python == 3.6
  \item python3-venv
  \item pip3
  \item typical build system
  \begin{itemize}
    \item make
    \item build
    \item git
    \item patch (bare-metal)
    \item libtool (if not installed, deployment can attempt to build and install)
    \item pkg-config (if not installed, deployment can attempt to build and install)
    \item build-essential (ubuntu package. named other things on other distros)
  \end{itemize}
  \item bash shell
\end{itemize}

Requirements (docker method):
\begin{itemize}
  \item linux os
  \item git
  \item docker running and working
\end{itemize}

\subsection{Deploy Methods}


There are 4 methods of building and deploying our batsim applications.
\begin{itemize}
  \item \textbf{bare-metal}
  \begin{itemize}[label=$-$]
    \item will compile and install everything you need into a directory
  \end{itemize}
  \item \textbf{docker}
  \begin{itemize}[label=$-$]
    \item will compile and install everything you need into a docker container
    \item currently there is no option of parallelism with this method
  \end{itemize}
  \item \textbf{charliecloud with internet}
  \begin{itemize}[label=$-$]
    \item charliecloud is a container technology that works when docker is not an option (think clusters without docker)
    \item will compile and install everything you need into a directory
  \end{itemize}
  \item \textbf{charliecloud without internet}
  \begin{itemize}[label=$-$]
    \item charliecloud is a container technology that works when docker is not an option (think clusters without docker)
    \item meant to be run where you have internet and then copy a folder (3.5GB) to the cluster without internet
    \begin{itemize}[label=$\diamond$]
        \item will compile and install everything you need and will be packaged into a directory to be copied to your setup without internet, then you can attempt to unpackage it there.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Deploy: How To...}

All of the methods rely on running \lstTerm{.../simulator/basefiles/deploy.sh}.  One can run \lstTerm{deploy.sh --help} for complete usage info.

\subsubsection{Bare-Metal}

\begin{enumerate}
  \item obtain the code
  \item change directories
  \item deploy
\end{enumerate}
\begin{hiterminal}
git clone https://cswalke1:ekhr1Q_mL356zvCt_p2B@gitlab.newmexicoconsortium.org/lanl-ccu/simulator.git
cd simulator/basefiles
./deploy.sh -f bare-metal --prefix $(dirname $(pwd))
\end{hiterminal}


\subsubsection{Docker}

\begin{enumerate}
  \item obtain the code
  \item change directories
  \item deploy
\end{enumerate}
\begin{hiterminal}
git clone https://cswalke1:ekhr1Q_mL356zvCt_p2B@gitlab.newmexicoconsortium.org/lanl-ccu/simulator.git
cd simulator/basefiles
./deploy.sh -f docker
\end{hiterminal}

\subsubsection{CharlieCloud with Internet}

\begin{enumerate}
  \item obtain the code
  \item change directories
  \item deploy
\end{enumerate}
\begin{hiterminal}
git clone https://cswalke1:ekhr1Q_mL356zvCt_p2B@gitlab.newmexicoconsortium.org/lanl-ccu/simulator.git
cd simulator/basefiles
./deploy.sh -f charliecloud
\end{hiterminal}

\subsubsection{CharlieCloud without Internet}

\begin{enumerate}
  \item obtain the code
  \item change directories
  \item deploy package
  \item change directories
  \item scp folder
  \item ssh to remote
  \item change directories
  \item unpackage
\end{enumerate}
\begin{hiterminal}
git clone https://cswalke1:ekhr1Q_mL356zvCt_p2B@gitlab.newmexicoconsortium.org/lanl-ccu/simulator.git
cd simulator/basefiles
./deploy.sh -f charliecloud --no-internet --package
cd ../../

#to be modified for your method of sending a folder to your remote location and logging in to your remote location
scp -r ./batsim_packaged user@remote.org:/home/USER/
ssh user@remote.org


cd /home/USER/batsim_packaged
./deploy.sh -f charliecloud --no-internet --un-package
\end{hiterminal}

% ----------------------------------------------------------------------------->
%-- -----------------------  Make Sure Everything Works  ------------------- -->
% ----------------------------------------------------------------------------->



\subsection{Make Sure Everything Works}
Here you will learn how to test that your deployment works.  You can make sure your particular deployment works by using our tests: \lstTerm{.../simulator/basefiles/tests/test_simulator.py}.


Keep in mind that SLURM tests assume the following:
\begin{itemize}
  \item You are on a cluster running SLURM
  \item You have access to at least two (2) nodes, otherwise it's not much of a parallel test
\end{itemize}
 
\subsubsection{Bare-Metal works}

Read the following list of instructions and then perform the commands below it.
\begin{enumerate}
  \item change directories \lstFolder{/path/to/simulator/basefiles}
  \item edit \lstTerm{batsim_environment.sh}
  \item source \lstTerm{batsim\_environment.sh}
  \item run \lstTerm{test_simulator.py}
  \item make your selections:
  \begin{itemize}
    \item choose local or slurm
    \item choose bare-metal
    \item choose either serial or parallel
    \begin{itemize}
      \item serial will run 1 simulation per test, 1 at a time
      \item parallel will give you options of how many simulations per test, and how many at a time per test
      \begin{itemize}
        \item if local was chosen this will use background multiple processes
        \item if slurm was chosen this will submit multiple jobs to SLURM  
      \end{itemize}
    \end{itemize}
  \end{itemize}
  \item wait for results
\end{enumerate}
\begin{hiterminal}
cd /path/to/simulator/basefiles
# edit ./batsim_environment.sh   
# make sure you point prefix to /path/to/simulator (don't include basefiles in the path)
source batsim_environment.sh
test_simulator.py
\end{hiterminal}

\subsubsection{Docker works}

Read the following list of instructions and then perform the commands below it.
\begin{enumerate}
  \item create and run a container from your "simulator\_compile" image
  \item change directories (should already be in the correct directory)
  \item edit \lstTerm{basefiles/batsim_environment.sh} 
  \item source \lstTerm{batsim_environment.sh}
  \item run \lstTerm{test_simulator.py}
  \item make your selections:
  \begin{itemize}
    \item choose local or slurm
    \item choose docker
    \item serial is the only option here, so the simulations will start immediately
  \end{itemize}
  \item wait for results
\end{enumerate}
\begin{hiterminal}
docker run -it --name sim_test simulator_compile:latest
inside docker> cd /home/sim/simulator/basefiles
inside docker> # edit ./batsim_environment.sh  # prefix should be /home/sim/simulator
inside docker> source batsim_environment.sh
inside docker> test_simulator.py
\end{hiterminal}

\subsubsection{CharlieCloud works}

Read the following list of instructions and then perform the commands below it.

\begin{enumerate}
  \item change directories \lstFolder{/path/to/simulator/basefiles}
  \item edit \lstTerm{batsim_environment.sh}
  \item source \lstTerm{batsim_environment.sh}
  \item run \lstTerm{test_simulator.py}
  \item make your selections:
  \begin{itemize}
    \item choose local or slurm
    \item choose charliecloud
    \item choose either serial or parallel
    \begin{itemize}
      \item serial will run 1 simulation per test, 1 at a time
      \item parallel will give you options of how many simulations per test, and how many at a time per test
      \begin{itemize}
        \item if local was chosen this will use background multiple processes
        \item if slurm was chosen this will submit multiple jobs to SLURM  
      \end{itemize}
    \end{itemize}
  \end{itemize}
  \item wait for results
\end{enumerate}
\begin{hiterminal}
cd /path/to/simulator/basefiles
# edit ./batsim_environment.sh
# make sure you point prefix to /path/to/simulator (don't include basefiles in the path)
source batsim_environment.sh
test_simulator.py
\end{hiterminal}

\section{Batsim Environment}

You always want to make sure you get into your batsim environment first.

To get into your batsim environment:

\begin{hiterminal}
cd /path/to/simulator/basefiles
# make sure prefix is set in batsim_environment.sh
source batsim_environment.sh
\end{hiterminal}

Once you are in your batsim environment you have a few tools to use:
\begin{itemize}
   \item \textbf{batEnv}
   \begin{itemize}  
      \item Tells you what batsim environment you are in (prefix).  This is helpful if you have multiple deployments.
   \end{itemize}
   \item \textbf{batVersion}
   \begin{itemize}
      \item Tells you what version of simulator you are using.  If one has problems it would be helpful to include:
      \begin{itemize}
        \item batsim version
        \item batsched version
        \item batVersion
      \end{itemize}
    \end{itemize}
    \item \textbf{batExit}
    \begin{itemize}
      \item gets you out of the batsim environment.  
      \item changes your:
      \begin{itemize}
          \item PATH - removes some added paths
          \item LD\_LIBRARY\_PATH - removes some added paths
          \item deactivates your python environment
          \item removes the (batsim\_env) from your prompt
      \end{itemize}
    \end{itemize}
    \item \textbf{batFile}
    \begin{itemize}
      \item makes it easier to select a file to pass to myBatchTasks.sh
      \begin{itemize}
        \item displays your configs directory and allows you to choose the numbered config file to set as \$file1 .
      \end{itemize}
      \item also helps you select a folder.
      \item use \lstTerm{batFile --help} for full usage.
    \end{itemize}
    \item \textbf{batFolder}
    \begin{itemize}
      \item makes it easier to select a folder.
      \item use \lstTerm{batFolder --help} for full usage.
    \end{itemize}
    \item \textbf{batEdit}
    \begin{itemize}
      \item makes selecting a file easier, as well as editing the file.
      \item use \lstTerm{batEdit --help} for full usage.
    \end{itemize}
    \item \textbf{bind\_all}
    \begin{itemize}
      \item will bind certain keys to certain functions while inside the command-line terminal.
      \begin{itemize}
        \item very helpful bindings for the keyboard.  For instance: type \lstTerm{cd} then continue to press 'alt+y' and you will see the history of just your \lstTerm{cd} command.
      \end{itemize}
     \item use \lstTerm{bind-all --help} to view all bindings that are made.
    \end{itemize}
    \item \textbf{basefiles scripts}
    \begin{itemize}
      \item \textbf{\textit{myBatchTasks.sh}}
      \begin{itemize}
        \item the main script you will use.
        \item use \lstTerm{myBatchTasks.sh --help} to view the full usage.
      \end{itemize}
      \item \textbf{\textit{progress.sh}}
      \begin{itemize}
        \item a very helpful script to view the progress of running simulations.
        \item use \lstTerm{progress.sh --help} to view the full usage.
      \end{itemize}
      \item \textbf{\textit{aggregate\_makespan.py}}
      \begin{itemize}
        \item will aggregate results after simulations are finished.
        \item use \lstTerm{aggregate_makespan.py --help} to view the full usage.
      \end{itemize}
    \end{itemize}
\end{itemize}


\section{Config File - In Depth}
\subsection{Basic Outline}

Here you will see what a basic outline of a config file is.  It will give you a good overview of what is included in one.

\begin{hicode}[java]
    The general format of a config file:
    
    {       <------------------------------------   Opening curly brace to be proper json
    
        "Name1":{       <------------------------   The name of an experiment comes first.  
                                                    You can have multiple experiments
                                                    in one config file and each will end up 
                                                    in it~'~s own folder under the --output 
                                                    folder.Notice the opening and closing 
                                                    curly brace.  Make sure you put a comma 
                                                    after the closing curly brace if you 
                                                    plan on having another 
                                                    experiment in the same config file
                                                    

                                                    Json does not allow for comments
                                                    (unfortunately).  You may still want 
                ~\textcolor{comment-greenish}\#~                          ~\textcolor{comment-greenish}\textbackslash~        comments in your config,     
                ~\textcolor{comment-greenish}{\# python/shell comment}~      ~\textcolor{comment-greenish}\textbackslash~       however.  You can use all of these 
                                             ~\textcolor{comment-greenish}\textbackslash~      types of comments and it will get  
                // c/c++ style comment        \     removed before parsing.Be aware that it  
                /* c/c++ block style comment  /     can get difficult to trace down a  
                    Comments are fun.        /      simple mistake in your config when  
                    This comment is too.    /       many comments are used due
                                           ~\textcolor{comment-greenish}/~        to the line numbers being off and         
                                                    generally more clutter in your config.
                                                    But comments can make things a lot 
                                                    clearer, too.The original and a 
                                                    stripped version will be in your 
                                                    --output folder.
                */                
                
                
                "input":{    <-------------------   Always make sure you have an input and 
                                                    an output in your experiment
                
                    "node-sweep":{  <------------   It is MOST advisable to always start 
                                                    with a node-sweep.  All other sweeps 
                                                    can come after this one
                    
                    },
                    "synthetic-workload":{ <-----   Always include either a 
                                                    synthetic-workload or a 
                                                    grizzly-workload after your sweeps
                    
                    },
                    "option":value,        <-----   Include any options that will affect 
                                                    all of the jobs on the outside of any 
                                                    sweep or workload
                
                },    <--------------------------   Make sure you separate your input 
                                                    options with commas, but also 
                                                    remember to separate input
                                                    and output with a comma
                "output":{   <-------------------   Again, always make sure you have an 
                                                    input and output in your experiment
                
                    "option":value,   <----------   Output is a bit simpler than input.  
                                                    Just make sure it is valid json
                    "option":value
                
                }
        
        
        },     <---------------------------------   This closes the experiment and here 
                                                    we have a comma because we included 
                                                    another experiment "Name2"
        "Name2":{
            "input":{
            
                ...  <--------------------------    Make sure you replace this ellipsis 
                                                    with at least:
                                                        * a node-sweep
                                                        * a workload
            },
            "output":{
            
                ...  <--------------------------    You should replace ellipsis with 
                                                    at least:
                                                        * "AAE":true | "makespan":true
                
            }    <------------------------------    Close output
        }  <------------------------------------    Close "Name2"          
    }  <----------------------------------------    Close json
    
\end{hicode}
\subsection{Sweeps}

Learn what sweeps are and how to use them here.

\subsubsection{Explanation of Sweeps}

Here you will learn what Sweeps are.


Sweeps are what we call it when we make a parameterized option.  When you start out you will have one job called 'experiment\_1'.  If you add a sweep
that, say, sweeps over how many nodes your simulation will be using, then it will add to how many jobs you have.  

Let's say you sweep from 1,000 nodes to 2,000 nodes with a step of 250.  Then you will have:
\begin{itemize}
  \item experiment\_1: 1000 nodes
  \item experiment\_2: 1250 nodes
  \item experiment\_3: 1500 nodes
  \item experiment\_4: 1750 nodes
  \item experiment\_5: 2000 nodes
\end{itemize}

Now, the way sweeps work is that they loop over what is already there.  So if we add a failure sweep like SMTBF (\textbf{S}ystem \textbf{M}ean \textbf{T}ime \textbf{B}etween \textbf{F}ailure) after the node sweep, then it will take the first parameter of the SMTBF sweep and set it to the experiments 1-5 above.  But then it will copy those 5 experiments and set the failure parameter to the second parameter of the SMTBF sweep.

Let's say you sweep from a SMTBF of 20,000 seconds to 40,000 seconds with a step of 10,000.  Then you will have:

\begin{itemize}
  \item experiment\_1: 1000 nodes  SMTBF: 20,000 sec
  \item experiment\_2: 1250 nodes  SMTBF: 20,000 sec
  \item experiment\_3: 1500 nodes  SMTBF: 20,000 sec
  \item experiment\_4: 1750 nodes  SMTBF: 20,000 sec
  \item experiment\_5: 2000 nodes  SMTBF: 20,000 sec
  \item experiment\_6: 1000 nodes  SMTBF: 30,000 sec
  \item experiment\_7: 1250 nodes  SMTBF: 30,000 sec
  \item experiment\_8: 1500 nodes  SMTBF: 30,000 sec
  \item experiment\_9: 1750 nodes  SMTBF: 30,000 sec
  \item experiment\_10: 2000 nodes SMTBF: 30,000 sec
  \item experiment\_11: 1000 nodes SMTBF: 40,000 sec
  \item experiment\_12: 1250 nodes SMTBF: 40,000 sec
  \item experiment\_13: 1500 nodes SMTBF: 40,000 sec
  \item experiment\_14: 1750 nodes SMTBF: 40,000 sec
  \item experiment\_15: 2000 nodes SMTBF: 40,000 sec
\end{itemize}

So I hope you can see how the experiments add up quickly.
\begin{itemize}
  \item We started with 5 node parameters
  \item We added 3 SMTBF parameters
  \item This totals 5 * 3 = 15 jobs
\end{itemize}
If we add another sweep after the SMTBF sweep with 4 parameters that would be 5 * 3 * 4 = 60 jobs


\subsubsection{Types of Sweep Functions}

Sweeps can parameterize in multiple ways.  Here are the methods used:
\begin{itemize}
  \item \textbf{(iMMS)} integer Min Max Step
  \begin{itemize}
    \item start from the minimum to the maximum (inclusive) with a step (can be negative)
    \begin{hicode}[java]
    "min":0,
    "max":10,
    "step":2 \end{hicode}
  \end{itemize}
  \item \textbf{(fMMS)} float Min Max Step
  \begin{itemize}
    \item same as iMMS except you can use floating point numbers
  \end{itemize}
  \item \textbf{(iR)} integer Range
  \begin{itemize}
    \item simply a list of integers
    \begin{hicode}[java]
    "range":[10,20,30,80] \end{hicode}
  \end{itemize}
  \item \textbf{(fR)} float Range
  \begin{itemize}
    \item same as iR except for floats
  \end{itemize}
  \item \textbf{(iSR),(fSR)} integer Sticky Range and float Sticky Range
  \begin{itemize}
    \item just like \textbf{iR} and \textbf{fR} except it requires the amount of values to equal the amount of jobs made from sweeps before it.  Instead of adding any more jobs, it sets the values contained in it to the jobs already there.
    \item example:
    \begin{hicode}[java]
    "node-sweep":{"range":[1000,2000]},  //creates two jobs: experiment_1 and 
                                         //experiment_2
    "SMTBF-sweep":{"sticky-range":[20000,30000]} 
    // normally with "range" this would 
        //set 20,000 to experiment_1(1000 nodes) and experiment_2(2000 nodes) and 
        //set 30,000 to experiment_3(1000 nodes) and experiment_4(2000 nodes)
    //sticky-range, however, will
        //set 20,000 to experiment_1(1000 nodes)
        //set 30,000 to experiment_2(2000 nodes)
        //and that's all  
    //No experiment_3 or 4. It 'sticks' to what was there before. \end{hicode}
  \end{itemize}
  \item \textbf{(F)} formula
  \begin{itemize}
    \item used in conjunction with iR, fR, iSR, fSR, iMMS and fMMS.  You can set a formula here with 'i' as your variable.  Each number in your min/max/step or range will be passed in as 'i' to your formula and the result will be your number.  Makes it easier to read.
    \item Example:
    \begin{hicode}[java]
    "range":[2,3,4],
    "formula":"i*3600"  // will make 2 hours, 3 hours, 4 hours. 
                        // easier than 7200 sec,10800 sec,14400 sec \end{hicode}
    \item Example:
    \begin{hicode}[java]
    "min":1,
    "max":5,
    "step":1,
    "formula":"(10**i)/i"  // 'i' can be used multiple times.  
                           // Any python statement can be evaluated here.\end{hicode}
  \end{itemize}
\end{itemize}


\subsubsection{Current Sweeps Available - (Functions Allowed)}

Here are the current sweeps available and the parameterization allowed.  All sweep names end in "-sweep"


\begin{itemize}
  \item \textbf{checkpointError \textit{(fMMS,fR)}}
  \begin{itemize}
    \item Used in our Application Efficiency tests.  It adds/subtracts an error amount to optimal simulated checkpoint intervals
  \end{itemize}
  \item \textbf{checkpoint \textit{(iMMS,iR)}}
  \begin{itemize}
    \item The interval to use for simulated checkpoints.  This value is an integer, but can also be set to "optimal".
  \end{itemize}
  \item \textbf{coreCount \textit{(iMMS,iR)}}
  \begin{itemize}
    \item How many cores per node.  Currently only supported on fcfs\_fast2, easy\_bf\_fast2, and easy\_bf\_fast2\_holdback algorithms.
  \end{itemize}
  \item \textbf{corePercent \textit{(fMMS,fR)}}
  \begin{itemize}
    \item What percent of cores can be filled with 1 node jobs.  Currently only supported on fcfs\_fast2, easy\_bf\_fast2, and easy\_bf\_fast2\_holdback algorithms.
  \end{itemize} 
  \item \textbf{jobs \textit{(iMMS,iR)}}
  \begin{itemize}
    \item How many jobs out of the workload to use.
  \end{itemize}
  \item \textbf{MTTR \textit{(fMMS,fR,F)}}
  \begin{itemize}
    \item \textbf{M}ean \textbf{T}ime \textbf{T}o \textbf{R}epair.  Used in conjunction with failures to set how long a repair lasts.  It will come up with random repair times each time a machine goes down based on an exponential distribution.
  \end{itemize} 
  \item \textbf{node \textit{(fMMS,fR,F)}}
  \begin{itemize}
    \item How many nodes the cluster will have.
  \end{itemize}
  \item \textbf{performance \textit{(fMMS,fR)}}
  \begin{itemize}
    \item Will increase/decrease the length of all jobs by this factor (floating point)
  \end{itemize}
  \item \textbf{queueDepth \textit{(iMMS,iR)}}
  \begin{itemize}
    \item In conservative\_bf algorithm, will only schedule this amount of queued jobs before stopping.  This will speed things up considerably.
  \end{itemize}
  \item \textbf{repairTime \textit{(iMMS,iR,F)}}
  \begin{itemize}
    \item Similar to MTTR, but, instead of a random MTTR, this will set a fixed repair time for the whole simulation.
  \end{itemize}
  \item \textbf{reservation \textit{(None - explained in its own section)}}
  \begin{itemize}
    \item This is used in conjunction with conservative\_bf algorithm to simulate reservations.  There is a whole syntax to this, so one should look at the documentation for info on it.  More info at \hyperlink{Reservations}{Section 4.6: Reservations}.
  \end{itemize}
  \item \textbf{sharePackingHoldback \textit{(iMMS,iR)}}
  \begin{itemize}
    \item When using cores, this will holdback x amount of nodes for sharing jobs.  All other nodes will not share jobs.  Only used with easy\_bf\_fast2\_holdback algorithm.
  \end{itemize}
  \item \textbf{SMTBF \textit{(fMMS,fR,fSR,F)}}
  \begin{itemize}
    \item \textbf{S}ystem \textbf{M}ean \textbf{T}ime \textbf{B}etween \textbf{F}ailures.  Used as the primary source of failures.  It will come up with random failure times with an exponential distribution, and will come up with a random machine to have the failure with a normal distribution.
    \item has a compute-SMTBF-from-NMTBF option
    \begin{itemize}
      \item Will treat the values generated from this sweep as NMTBF's (\textbf{N}ode \textbf{M}ean \textbf{T}ime \textbf{B}etween \textbf{F}ailure) and will compute the SMTBF from the amount of nodes for that experiment
    \end{itemize}
  \end{itemize}
  \item \textbf{submissionCompression \textit{(iMMS,iR,F)}}
  \begin{itemize}
    \item will compress/expand the time between submissions by a factor.
  \end{itemize}
\end{itemize}

\subsection{Workloads}

Here you will learn about the mandatory workload keys in a config file.

The following keys will be explained:
\begin{itemize}
  \item grizzly-workload
  \item synthetic-workload
\end{itemize}

\subsubsection{grizzly-workload}

A grizzly-workload is named based on a certain 'grizzly' cluster at Los Alamos National Lab.  It is a 1490 node cluster and a 2018 real workload was acquired from the months of January to November.  
As long as the file the workload comes from conforms to the same requirements the 2018 workload conforms to, then the grizzly-workload is simply a 'real' workload that has options specific for it.  Requirements for your own 'grizzly-workload' are laid out in \lstFolder{.../simulator/basefiles/docs/User/User_Doc_Manual.pdf}

\begin{itemize}
  \item \textbf{\large{Required Options}}
  \begin{itemize}
    \item \textbf{\textit{type}}
    \begin{itemize}
      \item the type of profile to use: 'parallel\_homogeneous' or 'delay'. With 'parallel\_homogenous' run-time of a job is actually in terms of computational work done: flops/second.  It just so happens that when \lstProperty{machine-speed} is set to 1 then it translates into time.  \lstProperty{delay} deals only with time. Though 'parallel\_homogeneous' may seem more complicated, it is recommended since other options and algorithms may use this flops/second functionality, such as using \lstProperty{cores}.
    \end{itemize}
    \item \textbf{\textit{machine-speed}}
    \begin{itemize}
      \item used with 'parallel\_homogeneous'.  It is the amount of flops of computation done in 1 second.  We highly recommend you set this to 1.
    \end{itemize}
    \item \textbf{\textit{input}}
    \begin{itemize}
      \item the 'grizzly' or 'grizzly-like' workload file you will use.  \lstFolder{sanitized_jobs.csv} is the 2018 workload file we use.  Can be an absolute path or the name of a file in \lstFolder{.../simulator/basefiles}
    \end{itemize}
    \item \textbf{\textit{time}}
    \begin{itemize}
      \item the time interval you would like to use in the workload.
      \begin{itemize}
        \item example: '03-01-2018:04-01-2018' would do March 1 till April 1.
        \item example: ':'  would do all of the file. From Jan to November in the 2018 file.
        \item example: '06-01-2018:' or ':05-01-2018'  From June on or From start to May respectively.
      \end{itemize}
    \end{itemize}
  \end{itemize}
  \item \textbf{\large{Additional Options}}
  \begin{itemize}
    \item \textbf{\textit{number-of-jobs}}
    \begin{itemize}
      \item once a time period is chosen with \lstProperty{time}, you may choose how many of those jobs you want with this.  Starts from the front of \lstProperty{time} with a positive number.  Starts from the back with a negative number.  Takes precedence over regular option \lstProperty{number-of-jobs} and the \lstProperty{jobs-sweep}, so it should not be set if using the \lstProperty{jobs-sweep}.
    \end{itemize}
    \item \textbf{\textit{random-selection}}
    \begin{itemize}
      \item used with \lstProperty{number-of-jobs}, will randomize which jobs are chosen.
      \begin{itemize}
        \item example: 20  will seed the randomness with 20, making it deterministic
        \item example: -1 will seed with time, making it random
      \end{itemize}
    \end{itemize}
    \item \textbf{\textit{submission-time}}
    \begin{itemize}
      \item The time between submissions and randomness used.  If omitted, will use the actual submission time in the \lstProperty{input} file. If set to '0:fixed', all jobs will submit at time zero.
      \begin{itemize}
        \item syntax: <float>:<exp|fixed>. will use <float> seconds as the mean time ('exp'onential) or the actual time (fixed)
        \item syntax: <float1>:<float2>:unif. will use a uniform distribution between <float1> and <float2>
      \end{itemize}
    \end{itemize}
    \item \textbf{\textit{wallclock-limit}}
    \begin{itemize}
      \item the amount of time that a job is able to use. If omitted, will use the actual wallclock-limit from the \lstProperty{input} file. 
      \begin{itemize}
        \item syntax: <float>|'<int>\%' a percent will be based off of the runtime of the job.
        \item syntax: <string> either 'min:max[:seed]' or 'min\%:max\%[:seed]'  where min:max are floats and min\% and max\% are '<int>\%'.  These are random numbers from min to max and an optional seed
        \item example: '98\%:102\%:10'  from 98\% of runtime to 102\% of runtime with a seed of 10
      \end{itemize}
    \end{itemize}
    \item \textbf{\textit{read-time}}
    \begin{itemize}
      \item The amount of time to read in from a simulated checkpoint if checkpointing is turned on.  Follows the same syntax as \lstProperty{wallclock-limit}.  Mandatory if using checkpointing, but can be set to 0.
    \end{itemize}
    \item \textbf{\textit{dump-time}}
    \begin{itemize}
      \item The amount of time to write out a simulated checkpoint if checkpointing is turned on.  Follows the same syntax as \lstProperty{wallclock-limit}.  Mandatory if using checkpointing, but can be set to 0.
    \end{itemize}
    \item \textbf{\textit{checkpoint-interval}}
    \begin{itemize}
      \item The amount of time between successive writes of a simulated checkpoint on a per job basis.  Follows the same syntax as \lstProperty{wallclock-limit}.  Not mandatory since a system-wide simulated checkpoint interval can be set.
    \end{itemize}
    \item \textbf{\textit{resv}}
    \begin{itemize}
      \item Sets what reservation definition to use.  Only used if you are simulating reservations of time, and only used with conservative\_bf algorithm.
    \end{itemize} 
    \item \textbf{\textit{force-creation}}
    \begin{itemize}
      \item Workloads go in a database and will be re-used if they have the right characteristics.  If you want to roll the dice again you should force the creation of a new workload.
    \end{itemize}
    \item \textbf{\textit{seed}}
    \begin{itemize}
      \item A seed that can be used on all randomness of the workload creation.  Otherwise it will use time, making it random unless individual seed options are used.
    \end{itemize}
    \item \textbf{\textit{index}}
    \begin{itemize}
      \item Will set the index for a workload.  Suppose you made a random workload and it was added to the database.  You then wanted to run the experiment again but wanted a different roll of the dice for randomness, you could choose \lstProperty{force-creation} or just give it another index.  The benefit of using an index is that you could come back to using the same workload as long as the other workload options remained the same.
    \end{itemize}
  \end{itemize}

  \item \textbf{\large{Regular Options That Effect Workloads}}
  \begin{itemize}
    \item \textbf{\textit{submission-compression}}
    \begin{itemize}
      \item will compress/expand the time between submission of jobs
      \begin{itemize}
        \item syntax: '<int>\%' . below 100\% compresses, above 100\% expands
      \end{itemize}
    \end{itemize}
    \item \textbf{\textit{reservations-} and \textit{reservation-sweep}}
    \begin{itemize}
      \item will define a reservation.  If \lstProperty{resv} is set for the workload then this changes the workload. See the section on reservations.  More info at \hyperlink{Reservations}{Section 4.6: Reservations}.
    \end{itemize}
    \item \textbf{\textit{workload-ids}}
    \begin{itemize}
      \item This option piggy-backs off the \lstProperty{index} idea.
      \begin{itemize}
        \item Jobs and Runs 
        \begin{itemize}
          \item If you want different options you make multiple jobs in the form of \lstFolder{experiment_#} folders.  
          \item If those options make batsim use randomness and you want to do some statistics by running batsim multiple times you use 'runs' by setting \lstProperty{avg-makespan} in the \lstCode{'output':{ }} section of your config.
        \end{itemize}
        \item Ids
        \begin{itemize}
          \item In contrast, if you want to make multiple random \textbf{workloads} for statistics, then you use 'ids' which can also be used in tandem with 'runs', though this gets complicated and may not aggregate properly at the time of this writing.TODO
        \end{itemize}
        \begin{itemize}
          \item syntax: '[<comma seperated range of ids>]', example: '[1,5,8,20]'  , yes this is a string
          \item syntax: 'min;max;step', example: '5;20;1' 
        \end{itemize}
      \end{itemize}
    \end{itemize}
    \item \textbf{\textit{number-of-jobs}}
    \begin{itemize}
      \item Although \lstProperty{number-of-jobs} in the workload section takes precedence, \lstProperty{number-of-jobs} can be set in the regular options as well.  This is purely for the benefit of the \lstProperty{jobs-sweep}.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsubsection{synthetic-workload}

A synthetic-workload is simply a completely, or almost completely, made up workload.  There are many random options to give you the workload you require.

The reason we say 'almost completely' made up, is that there are 6 files that characterize different types of workloads based on the grizzly cluster.  In fact 'wl2.csv' was made from the same distribution of jobs that is in a particular real grizzly workload.

Whether you use these files or not is completely up to you.  We give you the tools to make a workload that suits you in the following list of options.
\begin{itemize}
  \item \textbf{\large{Required Options}}
  \begin{itemize}
    \item \textbf{\textit{type}}
    \begin{itemize}
      \item the type of profile to use: \lstProperty{'parallel_homogeneous'} or \lstProperty{'delay'}. With \lstProperty{'parallel_homogenous'} run-time of a job is actually in terms of computational work done: flops/second.  It just so happens that when \lstProperty{machine-speed} is set to 1 then it translates into time.  \lstProperty{'delay'} deals only with time. Though \lstProperty{'parallel_homogeneous'} may seem more complicated, it is recommended since other options and algorithms may use this flops/second functionality, such as using cores.
    \end{itemize}
    \item \textbf{\textit{machine-speed}}
    \begin{itemize}
      \item used with \lstProperty{'parallel_homogeneous'}.  It is the amount of flops of computation done in 1 second.  We highly recommend you set this to 1.
    \end{itemize}
    \item \textbf{\textit{number-of-jobs}}
    \begin{itemize}
      \item The total number of jobs to make
    \end{itemize}
    \item \textbf{\textit{number-of-resources}}
    \begin{itemize}
      \item The number of resources that each job will use
      \begin{itemize}
        \item syntax: '<int>:fixed'
        \begin{itemize}
          \item all jobs will have a fixed <int> amount of resources
        \end{itemize}
        \item syntax: '<int1>:<int2>:unif'
        \begin{itemize}
          \item jobs will have from <int1> to <int2> uniformally random number of resources
        \end{itemize}
        \item syntax: '<float1>:<float2>:norm'
        \begin{itemize}
          \item jobs will have from <float1> to <float2> normally random number of resources
        \end{itemize}
        \item syntax: '<str>:<int>:csv'
        \begin{itemize}
          \item Will come from csv file at <str>.  <str> can be an absolute path or a file in \lstFolder{.../simulator/basefiles}.  <int> is the position in each row that holds the number of resources in the file. 0 is the first column.
          \item csv files included are from \lstFolder{wl1.csv} to \lstFolder{wl6.csv}. \lstFolder{wl1.csv} starts at all 1 node jobs, \lstFolder{wl2.csv} is mostly 1 node jobs but resembles grizzly workloads in the past. \lstFolder{wl3.csv} is medium sized all the way up to \lstFolder{wl6.csv} which is the entire 1490 cluster on every job.
        \end{itemize}
      \end{itemize} % end syntax 
    \end{itemize} % end description
    \item \textbf{\textit{duration-time}}
    \begin{itemize}
      \item The length of time each job will use to complete
      \begin{itemize}
        \item syntax: '<float>:<exp|fixed>'
        \begin{itemize}
          \item all jobs will have a fixed <float> amount of runtime or an exponentially random runtime with a <float> mean time.
        \end{itemize}
        \item syntax: '<float1>:<float2>:unif'
        \begin{itemize}
          \item jobs will have from <float1> to <float2> uniformally random number of runtime
        \end{itemize}
        \item syntax: '<float1>:<float2>:norm'
        \begin{itemize}
          \item jobs will have from <float1> to <float2> normally random number of runtime
        \end{itemize}
        \item syntax: '<str1>:<int>:<str2>:csv'
        \begin{itemize}
          \item Will come from csv file at <str1>.  <str1> can be an absolute path or a file in \lstFolder{.../simulator/basefiles}.  <int> is the position in each row that holds the number of resources in the file. 0 is the first column.<str2> is the unit of time that this represents in the file, so 'h|m|s' for hours or minutes or seconds. 'h' should be used with the included files.
          \item csv files included are from \lstFolder{wl1.csv} to \lstFolder{wl6.csv}. \lstFolder{wl1.csv} is all 24 hour jobs as their width is only 1 resource. \lstFolder{wl2.csv} is varied but resembles grizzly workloads in the past. \lstFolder{wl3.csv} is medium length all the way up to \lstFolder{wl6.csv} which is entirely 24 hour jobs.
        \end{itemize}
      \end{itemize} % end syntax
    \end{itemize} % end description
    \item \textbf{\textit{submission-time}}
    \begin{itemize}
      \item The time between submissions and randomness used. If set to 0:fixed, all jobs will submit at time zero.
      \begin{itemize}
        \item syntax: '<float>:<exp|fixed>'
        \begin{itemize}
          \item all jobs will have a fixed <float> amount of time between submissions or an exponentially random time with a <float> mean time between submissions.
        \end{itemize}
        \item syntax: '<float1>:<float2>:unif'
        \begin{itemize}
          \item jobs will have from <float1> to <float2> uniformally random number of time between submissions
        \end{itemize}
        \item syntax: '<float1>:<float2>:norm'
        \begin{itemize}
          \item jobs will have from <float1> to <float2> normally random number of time between submissions
        \end{itemize}
      \end{itemize} % end syntax
    \end{itemize} % end description
  \end{itemize} % required options
  \item \textbf{\large{Additional Options}}
  \begin{itemize}
    \item \textbf{\textit{wallclock-limit}}
    \begin{itemize}
      \item the amount of time that a job is able to use. If omitted, will use -1, which means that it will not be used in Batsim.
      \begin{itemize} 
        \item syntax: <float>|'<int>\%' a percent will be based off of the runtime of the job.
    
        \item syntax: <string> either 'min:max[:seed]' or 'min\%:max\%[:seed]'  where min:max are floats and min\% and max\% are '<int>\%'.  These are random numbers from min to max and an optional seed
        \begin{itemize}
          \item example: '98\%:102\%:10'  from 98\% of runtime to 102\% of runtime with a seed of 10
        \end{itemize}
      \end{itemize} % end syntax
    \end{itemize} % description
    \item \textbf{\textit{read-time}}
    \begin{itemize}
      \item The amount of time (in seconds) to read in from a simulated checkpoint if checkpointing is turned on.  Follows the same syntax as wallclock-limit.  Mandatory if using checkpointing, but can be set to 0.
    \end{itemize}
    \item \textbf{\textit{dump-time}}
    \begin{itemize}
      \item The amount of time (in seconds) to write out a simulated checkpoint if checkpointing is turned on.  Follows the same syntax as wallclock-limit.  Mandatory if using checkpointing, but can be set to 0.
    \end{itemize}
    \item \textbf{\textit{checkpoint-interval}}
    \begin{itemize}
      \item The amount of time (in seconds) between successive writes of a simulated checkpoint on a per job basis.  Follows the same syntax as wallclock-limit.  Not mandatory since a system-wide simulated checkpoint interval can be set.
    \end{itemize}
    \item \textbf{\textit{resv}}
    \begin{itemize}
      \item Sets what reservation definition to use.  Only used if you are simulating reservations of time, and only used with \lstProperty{conservative_bf} algorithm. More info at \hyperlink{Reservations}{Section 4.6: Reservations}.
    \end{itemize}
    \item \textbf{\textit{force-creation}}
    \begin{itemize}
      \item Workloads go in a database and will be re-used if they have the right characteristics.  If you want to roll the dice again you should force the creation of a new workload.
    \end{itemize}
    \item \textbf{\textit{seed}}
    \begin{itemize}
      \item A seed that can be used on all randomness of the workload creation.  Otherwise it will use time, making it random unless individual seed options are used.
    \end{itemize}
    \item \textbf{\textit{index}}
    \begin{itemize}
      \item Will set the index for a workload.  Suppose you made a random workload and it was added to the database.  You then wanted to run the experiment again but wanted a different roll of the dice for randomness, you could choose \lstProperty{force-creation} or just give it another index.  The benefit of using an index is that you could come back to using the same workload as long as the other workload options remained the same.
    \end{itemize}
  \end{itemize} % end Additional options
  \item \textbf{\large{Regular Options That Effect Workloads}}
  \begin{itemize}
    \item \textbf{\textit{submission-compression}}
    \begin{itemize}
      \item will compress/expand the time between submission of jobs
      \begin{itemize}
        \item syntax: '<int>\%' . below 100\% compresses, above 100\% expands
      \end{itemize} % end syntax
    \end{itemize} % end description
    \item \textbf{\textit{reservations}} and \textbf{\textit{reservation-sweep}}
    \begin{itemize}
      \item will define a reservation.  If \lstProperty{resv} is set for the workload then this changes the workload.  More info at \hyperlink{Reservations}{Section 4.6: Reservations}.
    \end{itemize}
    \item \textbf{\textit{workload-ids}}
    \begin{itemize}
      \item This option piggy-backs off the \lstProperty{index} idea.
      \begin{itemize}
        \item Jobs and Runs
        \begin{itemize}
          \item If you want different options you make multiple jobs in the form of \lstFolder{experiment_#} folders.  
          \item If those options make batsim use randomness and you want to do some statistics by running batsim multiple times you use 'runs' by setting \lstProperty{avg-makespan} in the \lstCode{'output':{}} section of your config.
        \end{itemize}
        \item Ids
        \begin{itemize}
          \item In contrast, if you want to make multiple random \textbf{workloads} for statistics, then you use 'ids' which can also be used in tandem with 'runs', though this gets complicated and may not aggregate properly at the time of this writing.TODO.
        \end{itemize}
        \begin{itemize}
          \item syntax: '[<comma seperated range of ids>]', example: '[1,5,8,20]'  , yes this is a string
          \item syntax: 'min;max;step', example: '5;20;1'
        \end{itemize}
      \end{itemize} % end further description
    \end{itemize} % end description
    \item \textbf{\textit{number-of-jobs}}
    \begin{itemize}
      \item Although \lstProperty{number-of-jobs} in the workload section takes precedence, \lstProperty{number-of-jobs} can be set in the regular options as well.  This is purely for the benefit of the \textbf{jobs-sweep}.
    \end{itemize}
  \end{itemize} % end Regular Options effect Workloads
\end{itemize} % end list of options
\subsection{Regular Options}

All other available options are described here.

\begin{itemize}
  \item \textbf{\large{Required Options}}
  \begin{itemize}
    \item \textbf{\textit{batsched-policy}}
    \begin{itemize}
      \item Sets which scheduling algorithm to use.  Is mandatory.
      \begin{itemize}
        \item options: \lstProperty{fcfs_fast2 | easy_bf_fast2 | easy_bf_fast2_holdback | easy_bf2 | easy_bf3 | conservative_bf}
        \item algorithms discussed in \hyperlink{Algorithms}{Section 4.5: Algorithms}
      \end{itemize}
    \end{itemize} % end description
  \end{itemize} % end Required Options
  \item \textbf{\large{Options That Can Effect The Workload}}
  \begin{itemize}
    \item \textbf{\textit{submission-compression}}
    \begin{itemize}
      \item will compress/expand the time between submission of jobs
      \begin{itemize}
        \item syntax: '<int>\%' . below 100\% compresses, above 100\% expands
      \end{itemize} %end syntax
    \end{itemize} %end description
    \item \textbf{\textit{reservations-}} and \textbf{\textit{reservation-sweep}}
    \begin{itemize}
      \item will define a reservation.  If \lstProperty{resv} is set for the workload then this changes the workload.  More info at \hyperlink{Reservations}{Section 4.6: Reservations}.
    \end{itemize}
    \item \textbf{\textit{workload-ids}}
    \begin{itemize}
      \item This option piggy-backs off the \lstProperty{index} idea.
      \begin{itemize}
        \item Jobs and Runs
        \begin{itemize}
          \item If you want different options you make multiple jobs in the form of \lstFolder{experiment_#} folders.  
          \item If those options make batsim use randomness and you want to do some statistics by running batsim multiple times you use 'runs' by setting \lstProperty{avg-makespan} in the \lstCode{'output':{}} section of your config.
        \end{itemize}
        \item Ids
        \begin{itemize}
          \item In contrast, if you want to make multiple random \textbf{workloads} for statistics, then you use 'ids' which can also be used in tandem with 'runs', though this gets complicated and may not aggregate properly at the time of this writing.TODO.
        \end{itemize}
        \begin{itemize}
          \item syntax: '[<comma seperated range of ids>]', example: '[1,5,8,20]'  , yes this is a string
          \item syntax: 'min;max;step', example: '5;20;1'
        \end{itemize}
      \end{itemize} % end further description
    \end{itemize} % end description
    \item \textbf{\textit{number-of-jobs}}
    \begin{itemize}
      \item Although \lstProperty{number-of-jobs} in the workload section takes precedence, \lstProperty{number-of-jobs} can be set in the regular options as well.  This is purely for the benefit of the \textbf{jobs-sweep}.
    \end{itemize}
  \end{itemize} % end Options effect Workloads
  \item \textbf{\large{Logging Options}}
  \begin{itemize}
    \item KEEP IN MIND THESE CAN TAKE UP A LOT OF HARD DRIVE SPACE, not meant to be used on a large set of simulations
    \item \textbf{\textit{batsched-log}}
    \begin{itemize}
      \item sets the logging for batsched
      \begin{itemize}
        \item options: \lstProperty{silent|debug|quiet|info|CCU_INFO|CCU_DEBUG_FIN|CCU_DEBUG|CCU_DEBUG_ALL}
        \begin{itemize}
          \item \textbf{silent} - No logging
          \item \textbf{debug} - Very verbose logging
          \item \textbf{quiet} - Very minimal logging
          \item \textbf{info} - A bit of logging
          \item \textbf{CCU\_INFO} - Minimal logging, tells you important things that are happening.  Could use with actual experiments, though not recommended
          \item \textbf{CCU\_DEBUG\_FIN} - Debug mode, but more important things.  Not recommended to be used with real experiments.
          \item \textbf{CCU\_DEBUG} - Debug mode, very verbose. Not recommended to be used with real experiments.
          \item \textbf{CCU\_DEBUG\_ALL} - Debug mode, extremely verbose.  Not recommended to be used with real experiments.
        \end{itemize} 
      \end{itemize} %end options
    \end{itemize} %end description
    \item \Opt{batsim-log}
    \begin{itemize}
      \item sets the logging for batsim
      \begin{itemize}
        \item options: \lstProperty{network-only|debug|quiet|info|CCU_INFO|CCU_DEBUG_FIN|CCU_DEBUG|CCU_DEBUG_ALL}
        \begin{itemize}
          \item \textbf{network-only} - only network logging
          \item \textbf{debug} - Very verbose logging
          \item \textbf{quiet} - Very minimal logging
          \item \textbf{CCU\_INFO} - Minimal logging, tells you important things that are happening.  Could use with actual experiments, though not recommended
          \item \textbf{CCU\_DEBUG\_FIN} - Debug mode, but more important things.  Not recommended to be used with real experiments.
          \item \textbf{CCU\_DEBUG} - Debug mode, very verbose. Not recommended to be used with real experiments.
          \item \textbf{CCU\_DEBUG\_ALL} - Debug mode, extremely verbose.  Not recommended to be used with real experiments.
        \end{itemize}
      \end{itemize} % end options
    \end{itemize} % end description
    \item \Opt{log-b-log}
    \begin{itemize}
      \item if set to true will log B\_LOG files ( these would need to be added to the scheduler code )
      \item more info on these are in the Development Docs \\
            \lstFolder{.../simulator/basefiles/docs/Developer/Developer_Doc_Manual.pdf}
    \end{itemize}
    \item \Opt{output-svg}
    \begin{itemize}
      \item Whether to output the schedule with algorithms that use the schedule
      \begin{itemize}
        \item options: \lstProperty{none | all | short}
        \begin{itemize}
          \item \textbf{'all'} -  will output a svg every time an output\_svg is encountered ( basically every time the schedule changes ). ONLY USE FOR SMALL WORKLOADS due to slow-down and Hard Drive space.
          \item \textbf{'short'} - will output a svg every time there is a short output\_svg ( happens much less than 'all').  STILL ONLY USE FOR SMALLER WORKLOADS due to slow-down and Hard Drive space 
          \item \textbf{'none'} - will not output the schedule at all.  The default.
        \end{itemize}
      \end{itemize} % end options
    \end{itemize} % end description
    \item \Opt{output-svg-method}
    \begin{itemize}
      \item What method to output the schedule
      \begin{itemize}
        \item options: \lstProperty{svg | text | both}
        \begin{itemize}
          \item \textbf{'svg'} - will output the svg files
          \item \textbf{'text'} -  will only output the schedule in text form in the batsched-log which requires it to be on info or CCU\_INFO
          \item \textbf{'both'} - will output svg files and also text in the log
        \end{itemize}
      \end{itemize} % end options
    \end{itemize} % end description
    \item \Opt{svg-output-start}
    \begin{itemize}
      \item What output number to start at.  If you know 'when' you want to concentrate on, in terms of how many svg's have been output, then set this number and possibly also the \lstProperty{svg-output-end}.
    \end{itemize}
    \item \Opt{svg-output-end}
    \begin{itemize}
      \item What output number to end at.  If you know 'when' you want to concentrate on, in terms of how many svg's have been output, then set this number and possibly also the \lstProperty{svg-output-start}.
    \end{itemize}
    \item \Opt{svg-frame-start}
    \begin{itemize}
      \item What frame number to start at.  A frame number is incremented each time make\_decisions() is entered.
    \end{itemize}
    \item \Opt{svg-frame-end}
    \begin{itemize} 
      \item What frame number to end at.  A frame number is incremented each time make\_decisions() is entered.
    \end{itemize}
    \item \Opt{svg-time-start}
    \begin{itemize} 
      \item What simulated time to start outputting the schedule.
      \begin{itemize}
        \item syntax: <float>, in seconds
      \end{itemize}
    \end{itemize} % end description
    \item \Opt{svg-time-end}
    \begin{itemize} 
      \item What simulated time to end outputting the schedule. -1.0 to go to the end of the simulation, the default.
      \begin{itemize}
        \item syntax: <float>, in seconds
      \end{itemize}
    \end{itemize} % end description
    \item \Opt{turn-off-extra-info}
    \begin{itemize}
      \item Extra info is output to a file called \lstFolder{out_extra_info.csv}.  It outputs a new line each time a job is completed.  It consists of 'jobs completed','percent done','utilization', schedule metrics, 'utilization', and memory usage.
      \begin{itemize}
        \item set to true to turn this off.  Turning off will render progress.sh useless but may speed things up and will reduce Hard Drive space.
      \end{itemize}
    \end{itemize} % end description
  \end{itemize} % end logging options
  \item \textbf{\large{Failure Options}}
  \begin{itemize}
    \item \Opt{MTTR}
    \begin{itemize}
      \item \textbf{M}ean \textbf{T}ime \textbf{T}o \textbf{R}epair. Used in conjunction with failures to set how long a repair lasts.  It will come up with random repair times each time a machine goes down based on an exponential distribution.
    \end{itemize}
    \item \Opt{SMTBF}
    \begin{itemize}
      \item \textbf{S}ystem \textbf{M}ean \textbf{T}ime \textbf{B}etween \textbf{F}ailures.  Used as the primary source of failures.  It will come up with random failure times with an exponential distribution, and will come up with a random machine to have the failure on with a normal distribution.
    \end{itemize}
    \item \Opt{calculate-checkpointing}
    \begin{itemize}
      \item If set to true, computes the optimal simulated checkpointing interval for each job based on read time and dump time and the failure rate
    \end{itemize}
    \item \Opt{checkpoint-interval}
    \begin{itemize} 
      \item Sets the system-wide simulated checkpoint interval
      \begin{itemize}
        \item syntax: <float>
      \end{itemize}
    \end{itemize} % end description
    \item \Opt{checkpointError}
    \begin{itemize} 
      \item Used in conjunction with \lstProperty{calculate-checkpointing}.  Will increase or decrease the computed optimal checkpoint by the factor given by \lstProperty{checkpointError}.
      \begin{itemize}
        \item syntax: <float>, above 1.0 is an increase, below 1.0 is a decrease.
      \end{itemize}
    \end{itemize} % end description
    \item \Opt{checkpointing-on}
    \begin{itemize}
      \item if set to true, will turn simulated checkpointing on.  Mandatory to do simulated checkpointing.
    \end{itemize}
    \item \Opt{fixed-failures}
    \begin{itemize}
      \item sets failures to be every simulated <float> seconds.  Is very useful in debugging.
    \end{itemize}
    \item \Opt{queue-policy}
    \begin{itemize}
      \item What the policy for the queue is when dealing with a re-submitted job.  The options are: \lstProperty{FCFS | ORIGINAL-FCFS}
      \item Usually the queue is FCFS based on the submit time. ORIGINAL-FCFS would put resubmitted jobs at the front of the queue based on their original submit time.
    \end{itemize}
    \item \Opt{reject-jobs-after-nb-repairs}
    \begin{itemize}
      \item When failures result in machines going down because of a repair time on them, some jobs may not be able to run at all until machines become available.  If there are only jobs in the queue that fall into this situation then a mode can be flipped to count how many times a repair is done before any job has executed.  Once a job is able to execute, the count is reset. This setting waits <int> number of repairs being done before it gives up and rejects the jobs that are left. '-1' means the jobs will never be rejected in this situation, the default.
      \begin{itemize}
        \item syntax: <int>
      \end{itemize}
    \end{itemize} %end description
    \item \Opt{repair-time}
    \begin{itemize}
      \item Sets a system-wide repair time in seconds.
      \begin{itemize}
        \item syntax: <float>
      \end{itemize}
    \end{itemize} %end description
    \item \Opt{seed-failures}
    \begin{itemize}
      \item Will seed any random generators for failures, otherwise time is used.
      \begin{itemize}
        \item syntax: <int>
      \end{itemize}
    \end{itemize} %end description
    \item \Opt{seed-failure-machine}
    \begin{itemize}
      \item Will seed any random generators for determining which machine should get the failure, otherwise time is used.
      \begin{itemize}
        \item syntax: <int>
      \end{itemize}
    \end{itemize} %end description
    \item \Opt{seed-repair-times}
    \begin{itemize}
      \item Will seed any random generators for repair time, otherwise time is used
      \begin{itemize}
        \item syntax: <int>
      \end{itemize}
    \end{itemize} % end description
  \end{itemize} % end Failure Options
  \item \textbf{\large{Real Checkpointing Options}}
  \begin{itemize}
    \item \Opt{checkpoint-batsim-interval}
    \begin{itemize}
      \item Will set an interval to do real checkpoints
      \begin{itemize}
        \item syntax: <string>
        \begin{itemize}
          \item "(real|simulated)[:once]:days-HH:MM:SS[:keep]"
          \begin{itemize}
            \item \textbf{'real'} - prepended will interpret the interval to be in real time
            \item \textbf{'simulated'} - prepended will interpret the interval to be in simulated time 
            \item \textbf{optional :once} - will do one checkpoint and then stop doing any more checkpoints
            \item \textbf{optional :keep} - will set the amount of checkpoints to keep.  \lstProperty{checkpoint-batsim-keep} trumps this
          \end{itemize}
        \end{itemize} % end syntax string
      \end{itemize} % end syntax
    \end{itemize} % end description
    \item \Opt{checkpoint-batsim-keep}
    \begin{itemize}
      \item How many checkpoints to keep
      \begin{itemize}
        \item syntax: <int>
      \end{itemize}
    \end{itemize} % end description
    \item \Opt{checkpoint-batsim-signal}
    \begin{itemize}
      \item The signal number to use for signal driven checkpointing.
      \begin{itemize}
        \item syntax: <int>, You will want to either use SIGUSR1(10), SIGUSR2 (12), or preferably real-time signals from 35-64
      \end{itemize}
    \end{itemize} % end description
  \end{itemize} %end real checkpointing options
  \item \textbf{\large{Speed/Core Options}}
  \begin{itemize}
    \item \Opt{core-percent}
    \begin{itemize}
      \item Sets the limit on how many cores from a node can be used
      \begin{itemize}
        \item syntax: <float> 
      \end{itemize}
    \end{itemize} %end description
    \item \Opt{core-count}
    \begin{itemize}
      \item Sets the amount of cores each node will have in the platform file and turns on \lstProperty{'--enable-compute-sharing'}
      \begin{itemize}
        \item syntax: <int>
      \end{itemize}
    \end{itemize} %end description
    \item \Opt{share-packing}
    \begin{itemize}
      \item If set to true, will pack single resource jobs onto one node until that node reaches \lstProperty{core-percent} * available cores
    \end{itemize}
    \item \Opt{share-packing-holdback}
    \begin{itemize}
      \item If set to true, will holdback a certain number of nodes for exclusive share-packing
    \end{itemize}
    \item \Opt{speeds}
    \begin{itemize}
      \item Will set the speed of the cluster in the platform file
      \begin{itemize}
        \item syntax: <string>, flops per second
        \begin{itemize}
          \item Where <string> is '<int>f'.  
          \item One can use size prefixes in front of 'f': K(10$^3$),M(10$^6$),G(10$^9$),T(10$^{12}$),P(10$^{15}$),E(10$^{18}$)
        \end{itemize}
        \item syntax: <string1>,<string2>,...
        \begin{itemize}
          \item The difference here is that a list of strings is given, one for each pstate you use.  pstates will be explained in both User and Developer Docs.
        \end{itemize}
      \end{itemize}%end different syntax
    \end{itemize} %end description
  \end{itemize} % end speed/core options
  \item \textbf{\large{ALL OTHER OPTIONS}}
  \begin{itemize}
    \item \Opt{copy}
    \begin{itemize}
      \item The amount of copies the ending workload will have, along with submission time optional options.  This can be used to double up a workload when you double up the amount of nodes the cluster has.  This operates at the Batsim level, and not during workload creation.
      \begin{termPESC}
        
format: 
<#copies>[:(+|-):#:(fixed|#:unif:(single|each-copy|all)[:<seed#>] ])'
    or  
<#copies>[:=:#(fixed|((exp|:#:unif)[:<seed#>]) ]'
So you can just do number of copies, or
'=':
   you can copy and set the submission time of the copy as an 
   exponential,uniform,or fixed amount with '=', or
'+|-':
   you can add a submission time to add some jitter. This submission time 
   is either added or subtracted with (+|-)
   This time can be a fixed number followed by :fixed or uniform random 
   number between 2 numbers
   If random:
     you need to specify the second number with :#:unif:
     you need to specify:  'single','each-copy',or 'all'
      'single' random number, single random number for 'each-copy', or 
      random number for 'all'
2 copies here means if there are 10 jobs to start with, there will be 
20 total after the operation.

 Examples:
                       '2'    - 2 copies no alteration in submission times
             '2:=:100:exp'    - 2 copies with 1 having original submission 
                                times, 1 having exponential random with a 
                                mean rate of 100 seconds.
             '2:=:0:fixed'    - 2 copies with 1 having original submission 
                                times, 1 having fixed time of 0
       '2:=:20:40:unif:30'    - 2 copies with 1 having original submission 
                                times, 1 having uniform random between 20 
                                and 40 seconds. Use 30 as seed.
            '2:+:10:fixed'    - 2 copies, add 10 seconds fixed jitter to 
                                submission times
            '2:-:10:fixed'    - 2 copies, subtract 10 seconds fixed jitter 
                                from submission times
    '2:+:5:10:unif:single'    - 2 copies, get one random number between 5 
                                and 10 and add it to all copied submission 
                                times
    '3:+:5:10:unif:all:20'    - 3 copies, get random numbers between 5 and 
                                10 for all jobs of all copies, add it to 
                                submission times and seed the random 
                                generator with 20
 '3:+:5:10:unif:each-copy'    - 3 copies, get one random number between 5 
                                and 10 and add it to all submission times 
                                of first copy then get another random number 
                                between 5 and 10 and add it to all sub 
                                times of second copy
      \end{termPESC}
    \end{itemize} %end description
    \item \Opt{submission-time-after}
    \begin{itemize}
      \item This dictates the time between submissions and what kind of randomness.  It happens AFTER the copy operation and after sorting the jobs based on submission time.  This operates at the Batsim level, and not during workload creation.
      \begin{termPESC}
format: 
'<#:(fixed[:#])|(exp|#:unif)[:(#|s[:#]])'
   or   
'shuffle[:#]'

It is applied after sorting the current workload by submit time and after 
applying the copy option
If zero is used for a float,combined with ":fixed" then all jobs will 
start at time zero.
If omitted, the original submission times will be used, be that grizzly 
produced or synthetically produced

exp:    This will be exponentially distributed, random values with mean 
        time between submissions to be FLOAT.
fixed:  All jobs will have this time between them unless zero is used 
        for a FLOAT.
unif:   This will be uniform, random values from min:max
s:      Used after the random types (exp|fixed|unif) to specify you want 
        the job's submit times shuffled after.
shuffle: Will simply shuffle around the submit times amongst the jobs.
#:      a seed can be put on the end of the string to use for deterministic 
        behavior
ex:
       '--submission-time-after "200.0:exp:s"'
       '--submission-time-after "100.0:fixed"'
       '--submission-time-after "0.0:fixed"'
       '--submission-time-after "0:200.0:unif"'
       '--submission-time-after "200.0:exp:10"'  <-- 10 is the seed
       '--submission-time-after "0:200.0:unif:20"' <-- 20 is the seed
       '--submission-time-after "shuffle:20" <-- 20 is the seed
      \end{termPESC}
    \end{itemize} %end description
    \item \Opt{submission-time-before}
    \begin{itemize}
      \item This is the same as \lstProperty{submission-time-after} except it happens BEFORE the copy operation and before sorting the jobs based on submission time. Both \lstProperty{submission-time-before} and \lstProperty{submission-time-after} can be used or either can be used on their own.
    \end{itemize}
    \item \Opt{performance-factor}
    \begin{itemize}
      \item Will increase/decrease the length of all jobs by this factor (floating point).  This operates at the Batsim level and not during workload creation.
      \begin{itemize}
        \item syntax: <float>, above 1.0 will increase, below 1.0 will decrease
      \end{itemize}
    \end{itemize} %end description
    \item \Opt{queue-depth}
    \begin{itemize}
      \item The amount of items in the queue that will be scheduled
      \begin{itemize}
        \item only used in conservative\_bf
        \item A lower amount will improve performance of the scheduler and thus the simulation but changes scheduling decisions and, so, gives different results
        \item (-1) sets it to all items being scheduled, the default
      \end{itemize}
    \end{itemize} % end description
    \item \Opt{reservations-start}
    \begin{itemize}
      \item Meant for monte-carlo with reservations, staggering their start time.  
      \begin{itemize}
        \item syntax: <string> 
        \item <string> is string in following format:
        \begin{termPESC}
'<order#>:<-|+><#seconds>'

where order# is the order (starting at 0) in the reservation array 
as described in your config file
where you (must) choose -(negative,behind) or +(positive,ahead)
where you specify the amount of seconds forward or backward

example_1: --reservations-start '0:+5'
              start the reservations with order# 0, 5 seconds ahead
example_2: --reservations-start '1:-2000'
              start the reservations with order# 1, 2000 seconds behind
example_3: --reservations-start '0:+5 , 1:-2000'
              only one invocation of this flag is allowed but values for 
              different order #s can be acheived with a comma. spaces 
              are allowed for easier viewing.
        \end{termPESC}
      \end{itemize} %end syntax
    \end{itemize} %end description
    \item \Opt{test-suite}
    \begin{itemize}
      \item If set to true, will assume the folder structure has an umbrella folder to it, where multiple configs were being used and so multiple base folders are used under the umbrella folder.
      \begin{itemize}
        \item This affects where the \lstFolder{current_progress.log} file is kept.  
        \item This file keeps track of which simulations are finished and which successfully output a \lstFolder{post_out_jobs.csv} file.  This helps the test-suite determine what simulations have finished and whether to go on to the next step or not.
        \item If an umbrella folder is used then \lstFolder{current_progress.log} is located one folder up from its base folder.   Otherwise it is located in its base folder.
      \end{itemize}
    \end{itemize}% end description
  \end{itemize} %end Other Options
\end{itemize} %end Options
\hypertarget{Algorithms}{}
\subsection{Algorithms}
While failures, simulated checkpointing, and real checkpointing should work with all algorithms, at the current moment only
fcfs\_fast2, easy\_bf2, and easy\_bf3 have had any rigorous testing.

It should be noted that real checkpointing does not produce the exact results as if it wasn't started from a checkpoint.
The way the message passing works prevented this.  It has been shown to be statistically the same with metrics like avg waiting time and makespan, however.
\subsubsection{fcfs\_fast2}
fcfs\_fast2 is a First Come First Serve basic algorithm.  It may be basic, but it is also a good starting point.  Jobs
come in at the 'subtime', start when they are first in the queue and resources are available, and then run for the cpu/delay time.
This algorithm is also equipped with some logic for 'cores' including the holding back of nodes for 1 core jobs.  If you find the logic
of cores useful you may be interested in easy\_bf\_fast2 and easy\_bf\_fast2\_holdback.
\subsubsection{easy\_bf2}
This is a basic backfilling algorithm, however we have found it to be slightly different than a 'normal' easy backfilling algorithm.  In addition, it uses the 'schedule' class to determine what nodes the priority job runs on.  The schedule
class becomes quite slow with a large queue so that should be considered.  A good alternative to this algorithm is the easy\_bf3 algorithm which we designed to be
in step with how most people think about easy backfilling algorithms, as well as skipping the use of the 'schedule' class.  This speeds the algorithm up
quite a bit, but it does not determine what nodes the priority job is going to run on in advance.

\subsubsection{easy\_bf3}
We designed this algorithm to be
in step with how most people think about easy backfilling algorithms, as well as skipping the use of the 'schedule' class.  This speeds the algorithm up
quite a bit, but it does not determine what nodes the priority job is going to run on in advance.
\subsubsection{conservative\_bf}
This algorithm is the only algorithm that you can use reservations with at this point in time.  This is because this algorithm
uses the 'schedule' class and schedules out the whole queue.  This makes it ideal for adding the reservation features.
It also makes the algorithm our slowest one, by far.  Something that can speed it up is using the \lstProperty{'queue-depth'} option.  This option
will limit how much of the queue gets scheduled before making decisions.
\subsubsection{easy\_bf\_fast2}
This algorithm is a bit different than easy\_bf2.  It does not follow your typical easy backfill algorithm.  But it has the 'cores' functionality that 'fcfs\_fast2' has with some version of backfilling to boot.
\subsubsection{easy\_bf\_fast2\_holdback}
This algorithm is the same as easy\_bf\_fast2 just with the ability to holdback nodes for 'cores'.
\hypertarget{Reservations}{}
\subsection{Reservations: All Things About Reservations}
Reservations are only compatible with the \lstProperty{"batsched-policy":"conservative_bf"}.  
\begin{itemize}
  \item They are blocks of time that appear like jobs, and actually run like a job with purpose: 'reservation' as opposed to 'job'.
  \item But their priority is higher than any other job.
  \item If there are other jobs running on the machines that the reservation takes during the time the reservation takes, then they are killed.
  \item Another distinction is that the reservation can specify which machines it runs on, whereas a job does not.
\end{itemize}
    

\subsubsection{Reservations}
Reservations start with a \lstCode{'reservations-<name>':{}} section in the config file.  You are defining a set of reservations with this key, named '<name>'.

There are two places you will potentially use this <name>: 
  \begin{itemize}
    \item You can include it in a \lstCode{'grizzly-workload':{}} or \lstCode{'synthetic-workload':{}} item.  
    \begin{itemize}
      \item You do this using the \lstProperty{'resv'} property within either of those workload items.
    \end{itemize}
    \item The other place to use the <name> is in a \lstCode{'reservation-sweep':{}} to specify which set of reservations the sweep applies to.
    \begin{itemize}
      \item You do this using the \lstProperty{'name'} property within the \lstCode{'reservation-sweep':{}}. 
    \end{itemize}  
  \end{itemize}
The first thing to start a \lstCode{'reservations-<name>':{}} section is the \lstProperty{'reservations-array'}.  This is mandatory
and includes an array of reservation types. \\

Here is an example array inside of a definition named 'test' of just 1 reservation type.  Everything will be explained below:
\begin{hicode}[java]
"reservations-test":
{
    "reservations-array":
    [
      {  
        "type":"parallel_homogeneous",
        "machines":
        {
            "prefix":"a",
            "machine-speed":1,
            "total-resources":"0-1489",
            "interval":"0-1489"
        },
        "subdivisions":128,      
        "subdivisions-unit":"1month 0days 00:00:00",
        "repeat-every":"1months 0days 00:00:00",
        "time":"09:00:00",
        "start":"1months 0days 12:00:00",
        "submit-before-start":"0months 7days 00:00:00",
        "submit":-1,
        "count":30
      }
    ]
}
\end{hicode}

So let's define each part of this reservation:

\begin{itemize}
  \item \textbf{\large{Time syntax:}}
  \begin{itemize}
    \item <string> in format: \lstCode{"[<int>month[s]][<int>day[s]] HH:MM:SS"}
    \begin{itemize}
      \item \textbf{\#month} - optionally the amount of months (simply the amount of seconds in 30 days * \#months).  Include an 's' at the end of month if you wish.
      \item \textbf{\#day} - optionally the amount of days (simply the amount of seconds in \#days).  Include an 's' at the end of day if you wish.
      \item \textbf{HH} - mandatory, the amount of Hours.  Must be greater than or equal to two digits.  Can set to 00 for zero.
      \item \textbf{MM} - mandatory, the amount of Minutes.  Must be greater than or equal to two digits.  Can set to 00 for zero.
      \item \textbf{SS} - mandatory, the amount of Seconds.  Must be greater than or equal to two digits.  Can set to 00 for zero.
    \end{itemize}
  \end{itemize}
  \item \textbf{\large{Required Fields:}}
  \begin{itemize}
    \item \Opt{type} (line 6)
    \begin{itemize}
      \item <str>. The profile type of this job/reservation \lstProperty{'parallel_homogeneous' | 'delay'}.  This is the same option for workloads.  Keep in mind, if you set it to parallel\_homogenous and the machine speed goes above/below what is set in this \lstCode{'machines':{}} section, the reservation will go faster/slower than the \lstProperty{'time'} set.
    \end{itemize}
    \item \Opt{machines} (line 7)
    \begin{itemize}
      \item <json>. The machines this reservation will use.  This gets its own section below, in order to properly explain it.
    \end{itemize}
    \item \Opt{start} (line 18)
    \begin{itemize}
      \item <str>.  The time to start the reservation.  Look at the Time Syntax at the top.
    \end{itemize}
    \item \Opt{time} (line 17)
    \begin{itemize}
      \item <str>.  The duration of the reservation.  Look at the Time Syntax at the top.
    \end{itemize}
    \item \Opt{count} (line 21)
    \begin{itemize}
      \item <int>. The amount of these reservations.  Should be 1 in a lot of cases, but pertains to certain \lstCode{'machines':{}} configurations, and also with \lstProperty{'repeat-every'} field.
    \end{itemize}
  \end{itemize}
  \item \textbf{\large{Optional Fields:}}
  \begin{itemize}
    \item \Opt{submit-before-start} (line 19)
    \begin{itemize}
      \item <str>.  required if \lstProperty{'submit'} is omitted. The amount of time to submit the reservation before the start of the reservation.  Look at the Time Syntax at the top.  This is a convenience field in place of using \lstProperty{'submit'} and trumps this field, as well.  It also allows for keeping up with different start times with \lstProperty{'repeat-every'}.
    \end{itemize}
    \item \Opt{submit} (line 20)
    \begin{itemize}
      \item <str>.  required if \lstProperty{'submit-before-start'} is omitted.  The absolute time at which to submit the reservation.  Look at the Time Syntax at the top. You can use -1 to signify submit time of zero.
    \end{itemize}
    \item \Opt{repeat-every} (line 16)
    \begin{itemize}
      \item <str>.  The amount of time before repeating the reservation.  Look at the Time Syntax at the top.  Used in conjunction with \lstProperty{'count'}.
    \end{itemize}
    \item \Opt{subdivisions} (line 14)
    \begin{itemize}
      \item <int>.  The amount of subdivisions to divide the machines into.  Imagine a 100 node reservation.  If we have 2 subdivisions then there will be 2 reservations of 50 nodes each. One will start at \lstProperty{'start'} and the other one will start at \lstProperty{'subdivisions-unit'}/2.
    \end{itemize}
    \item \Opt{subdivisions-unit} (line 15)
    \begin{itemize}
      \item <str>.  required if \lstProperty{'subdivisions'} used.  The amount of time to complete all subdivisions in, spaced evenly. Look at the Time Syntax at the top.  If the unit is 1 hour and we have 2 subdivisions, one will start at time \lstProperty{'start'} and the other at 30 minutes after that.  With 4 subdivisions that would be \lstProperty{'start'}, 15 min, 30 min, 45 min.
    \end{itemize}
  \end{itemize}
\end{itemize}



\subsubsubsection{machines}
The \lstCode{'machines':{}} section determines what machines the reservations will occur on.
\begin{itemize}
  \item Without the random aspects, the machines are static and will be applied to all reservations.
  \item With the random aspects, the machines will be different, or at least randomly chosen, for the reservations.
  \item The random aspects work with the \lstProperty{'count'} field of the reservation type.
\end{itemize}
\begin{itemize}
  \item \textbf{\large{IntervalSet syntax}}
  \begin{itemize}
    \item <str> in format: "\#-\# \# \#-\#".  Intervals are produced with "<min>-<max>" syntax.  Numbers and intervals are seperated with a space.
    \item examples:
    \begin{itemize}
      \item "1" - a single number. Gives you [1]
      \item "1-5" - a single interval. Gives you [1,2,3,4,5]
      \item "1-5 8-10 14 21-25 100" - multiple intervals and numbers. Gives you [1,2,3,4,5,8,9,10,14,21,22,23,24,25,100]
    \end{itemize}
  \end{itemize}
  \item \Opt{prefix}
  \begin{itemize}
    \item <str> required. The prefix of the machine name.  This actually isn't quite used yet, but is included as we use forward-thinking designs. Use "a" for now.  TODO
  \end{itemize}
  \item \Opt{machine-speed} 
  \begin{itemize}
    \item <int> required.  The machine-speed of the machine(s).  This will translate the times given in the reservation definition to the amount of flops of work when using \lstProperty{'type':'parallel_homogeneous'}.
  \end{itemize}
  \item \Opt{total-resources} 
  \begin{itemize}
    \item <str> required.  This is what resources we are starting with when talking about random selections of machines.  The string is an intervalset, with its syntax above.
  \end{itemize}
  \item \Opt{interval} 
  \begin{itemize}
    \item <str> required if \lstProperty{'resources'} omitted. These are the actual machines that the reservation will use.  Shows up as \lstProperty{'alloc'} for the machines, and as \lstProperty{'res'} for the amount of machines in the workload json file.  The string is an intervalset, with its syntax above.
    \begin{verbatim}
          

    or
    \end{verbatim}
    \item "random:unif [options]" - Will randomize the interval based on what resources are available given in \lstProperty{'total-resources'} and the following options:
    \begin{itemize}
      \item  \textbf{res-number} - The amount of resources to choose for each random interval.  Can be a "min,max" separated by a comma, in which case a random number between min-max will be chosen.  Can be an intervalset inside brackets, in which case a random number in the intervalset will be chosen.
      \item  \textbf{different-res-numbers} - The amount of different resource numbers. Can be a "min,max" separated by a comma. Can be an intervalset inside brackets. When set to -1 will do all of the choices in \textbf{"res-number"}.
      \item  \textbf{different-intervals} - For each resource number, how many different intervals.  Can be a "min,max" separated by a comma. Can be an intervalset inside brackets.  When set to -1 will make each one different.
      \item \textbf{\normalsize{Examples:}}
      \begin{itemize}
        \item \textbf{With each example assume} \lstProperty{'total-resources':"0-99"} and \lstProperty{'count':5}
        \item \lstProperty{"random:unif res-number=5 different-intervals=1"}
        \begin{itemize}
          \item will make one interval with 5 randomly chosen machines out of 0-99. For instance [10,20,55,72,85] for all 5 reservations
        \end{itemize}
        \item \lstProperty{"random:unif res-number=5 different-intervals=2"}
        \begin{itemize}
          \item will make 2 intervals with 5 randomly chosen machines out of 0-99. For instance [10,20,55,72,85] and [30,45,50,60,99].  It will assign the first interval to reservations 1-2 and the second to reservations 3-5.
        \end{itemize}
        \item \lstProperty{"random:unif res-number=5 different-intervals=-1"}
        \begin{itemize}
          \item will make 5 intervals with 5 randomly chosen machines out of 0-99. For instance [10,20,55,72,85] ,[30,45,50,60,99],[1,5,10,48,97],[8,9,22,24,63], and [33,76,82,93,99].  It will assign intervals 1-5 to reservations 1-5 respectively.
        \end{itemize}
        \item \lstProperty{"random:unif res-number=5,8 different-intervals=1}
        \begin{itemize}
          \item will make 1 interval of 5-8 randomly chosen machines out of 0-99.  For instance, if 6 is randomly chosen for the resource number, we can have [10,20,30,40,50,86] and this will be applied to all 5 reservations.
        \end{itemize}
        \item \lstProperty{"random:unif res-number=[5-8 10] different-intervals=1}
        \begin{itemize}
          \item will make 1 interval of 5,6,7,8 or 10 randomly chosen machines out of 0-99.  For instance, if 6 is randomly chosen for the resource number, we can have [10,20,30,40,50,86] and this will be applied to all 5 reservations.
        \end{itemize}
        \item \lstProperty{"random:unif res-number=5,8 different-intervals=2}
        \begin{itemize}
          \item will make 2 intervals of 5-8 randomly chosen machines out of 0-99.  For instance, if 6 is randomly chosen for the resource number, we can have [10,20,30,40,50,86] and [11,22,33,44,55,66]. Interval 1 will be applied to reservations 1-2 and interval 2 will be applied to reservations 3-5.
        \end{itemize}
        \item \lstProperty{"random:unif res-number=5,8 different-res-numbers=2 different-intervals=2}
        \begin{itemize}
          \item will choose 2 resource numbers between 5-8.  For each resource number ,'res', 2 intervals will be made from 'res' number of machines out of 0-99.  
          \item Say 5 and 7 are chosen as resource numbers. 
          \item For resources = 5, 2 different intervals of 5 machines each are chosen at random from 0-99. 
          \item For resources = 7, 2 different intervals of 7 machines each are chosen at random from 0-99.
          \item For instance, [10,20,30,40,50],[15,25,35,45,55],[10,20,30,40,50,60,70],[15,25,35,45,55,65,75],[15,25,35,45,55,65,75] are chosen for reservations 1-5.  2 size 5, 3 size 7, with only 1 repeat.
        \end{itemize}
      \end{itemize}
    \end{itemize}  
  \end{itemize}
  \item \Opt{resources}
  \begin{itemize}
    \item <int> required if \lstProperty{'interval'} omitted. These are the amount of machines used, but not specific machines.  The reservation will try not to kill any jobs, but still has the priority.  Shows up as \lstProperty{'res'} in the workload json file.
    \begin{verbatim}
          

    or
    \end{verbatim}
    \item <str> "random:unif [options]" - Will randomize the resources based on what resources are available given in \lstProperty{'total-resources'} and the following options:
    \begin{itemize}
      \item  \textbf{res-number} - The amount of resources.  Can be a "min,max" separated by a comma. Can be an intervalset inside brackets.
      \item  \textbf{different-res-numbers} - The amount of different resource numbers. Can be a "min,max" separated by a comma.Can be an intervalset inside brackets. When set to -1 will do all of the choices in \textbf{"res-number"}.
      \item \textbf{\normalsize{Examples:}}
      \begin{itemize}
        \item \textbf{With each example assume} \lstProperty{'total-resources':"0-99"} and \lstProperty{'count':5}
        \item \lstProperty{"random:unif res-number=5"}
        \begin{itemize}
          \item will make one in resource number 5 for all 5 reservations.
        \end{itemize}
        \item \lstProperty{"random:unif res-number=5,8 different-res-numbers=2}
        \begin{itemize}
          \item will make 2 resource numbers, randomly chosen from 5-8.  It will assign the first resource number to reservations 1-2, and the second to reservations 3-5.
        \end{itemize}
        \item \lstProperty{"random:unif res-number=[5-8 10] different-res-numbers=2"}
        \begin{itemize}
          \item will make 2 resource numbers, randomly chosen from 5,6,7,8,10.  It will assign the first resource number to reservations 1-2, and the second to reservations 3-5.
        \end{itemize}
        \item \lstProperty{"random:unif res-number=[1-4] different-res-numbers=-1}
        \begin{itemize}
          \item will make 4 resource numbers because the choices length is 4: 1,2,3,4.  It will assign resource numbers 1-4 to reservations 1-4, respectively, and reservation 5 will get 4 resources as well.
        \end{itemize}
        \item \lstProperty{"random:unif res-number=[1-4] different-res-numbers=[1-3]}
        \begin{itemize}
          \item will make a random choice on how many different resource numbers to choose, from 1-3, let's call that 'random1'. It will choose 'random1' numbers from 1,2,3,4 at random, let's call these 'random2'. It will distribute those to reservations 1-5 with any repeats happening at the end.  
        \end{itemize}
      \end{itemize}
    \end{itemize}  
  \end{itemize}
\end{itemize}
\pagebreak
\subsubsection{Reservation-Sweeps}
Reservation sweeps apply to an already defined reservation type, or types.

Let's look at an example to let you dive right in:

\input{reservation_sweep.tex}
This sweep starts out with the \lstProperty{'name'} of the definition this sweep applies to.  It then starts the \lstProperty{'reservations-array'}.

Each json object in this array maps onto the reservation type in the \lstProperty{'reservations-array'} of the reservation definition.  If you define two types
of reservations in your definition, then you should have two reservation sweep json objects in your \lstProperty{'reservations-array'} in your \lstCode{'reservation-sweep':{}} section.

The sweep above goes with the following reservation definition:
\begin{hicode}[java]
  "reservations-test":
  {
      "reservations-array":
      [
        {  
          "type":"parallel_homogeneous",
          "machines":
          {
              "prefix":"a",
              "machine-speed":1,
              "total-resources":"0-1489",
              "interval":"0-1489"
          },
          "subdivisions":128,      
          "subdivisions-unit":"1month 0days 00:00:00",
          "repeat-every":"1months 0days 00:00:00",
          "time":"09:00:00",
          "start":"1months 0days 12:00:00",
          "submit-before-start":"0months 7days 00:00:00",
          "submit":-1,
          "count":30
        }
      ]
  }
  \end{hicode}
So the main thing to learn in our sweeps are:
\begin{itemize}
  \item What jobs are being modified
  \item What jobs are being added
  \item In what order are jobs being modified and added
  \item The number of changes
  \item The syntax for sweeping
\end{itemize}

We will continue to show the sweep so that you won't have to look back too far.  So here it is again:
\input{reservation_sweep.tex}

The first thing to note is that all the options for the sweep are just the options that are used to define a reservation type in the first place.

But you'll notice that there are \textit{curly braces} with numbers inside for some of the \textbf{keys} and \textit{brackets} in some of the \textbf{values}.
\begin{itemize}
  \item The curly braces have to do with the order of the jobs as well as the grouping of multipliers
  \item The brackets have to do with lists of values and min;max;step
\end{itemize}

I think it's easiest to start with the base of the sweep on line 10.  you see \lstProperty{'subdivisions':"[2,4,8]}.  
\begin{itemize}
  \item No curly braces in the key says that this is the base.
  \item brackets in the value are mandatory, and a list is provided, as evidenced by the commas.
  \item If only the base were provided then this would:
  \begin{itemize}
    \item take all the jobs already made from previous sweeps
    \item apply the reservation definition 'test' to all of the jobs, but substitute \lstProperty{'subdivisions':2} for all those original jobs (the original 128 is not used at all in this case)
    \item copy all of those original jobs, but now substitute \lstProperty{'subdivisions':4}
    \item copy all of those original jobs, but now substitute \lstProperty{'subdivisions':8}
    \item So if we had 10 jobs originally, we would have 30 now
  \end{itemize}
\end{itemize}
You might be observant and question the other base property \lstProperty{'subdivisions-unit'} and ask why that doesn't do anything.  
Well it does.  I just wanted to complete at least 1 \textbf{key}:\textbf{value} train of thought.

For the 30 jobs that are made from the \lstProperty{'subdivisions'} property, add on to it these details:
\begin{itemize}
  \item In the base sweep we see we have 3 values so far: [2,4,8]
  \item All other \textbf{key}:\textbf{values} in the base should have 3 values to them as well, unless you use just 1 value.  If you use 1 value, it will just copy that value (3 times in this case).
  \item So what will happen with \lstProperty{'subdivisions-unit':"[1]month [00]:[00]:[00]"} is the following:
  \begin{itemize}
    \item It sees [1]month but the largest expansion in the base has 3 values, so it is really [1,1,1]month
    \item It sees [00] for hours, but the largest expansion in the base has 3 values, so it is really [00,00,00]:
    \item It sees [00] for minutes, but the largest expansion in the base has 3 values, so it is really[00,00,00]:
    \item It sees [00] for seconds, but the largest expansion in the base has 3 values, so it is really[00,00,00]:
    \item For all 10 jobs that has \lstProperty{'subdivisions':2} those will have \lstProperty{'subdivisions-unit':"1month 00:00:00"}
    \item For all 10 jobs that has \lstProperty{'subdivisions':4} those will have \lstProperty{'subdivisions-unit':"1month 00:00:00"}
    \item For all 10 jobs that has \lstProperty{'subdivisions':8} those will have \lstProperty{'subdivisions-unit':"1month 00:00:00"}
  \end{itemize}
  \item suppose we had \lstProperty{'subdivisions-unit':"[1,2]month [00]:[00]:[00]"}
  \begin{itemize}
    \item this would error as there are two values for month being mapped onto the largest expansion in the base of 3 values.
  \end{itemize}
  \item suppose we had \lstProperty{'subdivisions-unit':"[1,2,3]month [6,12,18]:[00]:[00]}
  \begin{itemize}
    \item this would be fine:
    \begin{itemize}
      \item \lstProperty{'subdivisions':2} would have \lstProperty{'subdivisions-unit':"1month 06:00:00"}
      \item \lstProperty{'subdivisions':4} would have \lstProperty{'subdivisions-unit':"2month 12:00:00"}
      \item \lstProperty{'subdivisions':8} would have \lstProperty{'subdivisions-unit':"3month 18:00:00"}
    \end{itemize}
  \end{itemize}
  \item suppose we had \lstProperty{'subdivisions-unit':"[1,2,3,4]month [00]:[00]:[00]"}
  \begin{itemize}
    \item this would error, but not because of \lstProperty{'subdivisions-unit'}, but because of \lstProperty{'subdivisions'}.
    \item \lstProperty{'subdivisions'} would have 3 values being mapped onto the largest expansion in the base of 4 values.
    \item if \lstProperty{'subdivisions'} did have the correct amount of values, say \lstProperty{'subdivisions':[2,4,8,16]}, then instead of 30 jobs, we would have 40 jobs.
  \end{itemize}
\end{itemize}
\textbf{\large{'expansion'}}\\
You might've been aware of our use of the word 'expansion' in the base explanation.  An expansion is just a list or a min;max;step which 'expands' into a list.

For instance, this: \lstProperty{'subdivisions-unit':"[1,2,3]month [6,12,18]:[00]:[00]"} \\
is the same as this: \lstProperty{'subdivisions-unit':"[1;3;1]month [6;18;6]:[00]:[00]"}

\textbf{\large{'curly braces'}}\\
So What about the curly braces? Well if they have just a number inside they are multipliers and the numbers are used to group them.

So let's look at our sweep again:
\input{reservation_sweep.tex}

  Line 14 shows us a multiplier and it's grouping is 1. What a multiplier does is it takes all the jobs that came before it and applies it's changes as new jobs.
  So here, if 10 jobs resulted from previous sweeps, we would have 30 jobs from the base part of the sweep.  From the multiplier with grouping '1' we would have the following:
\begin{itemize}
  \item To start we have:
  \begin{itemize}
    \item we have 10 jobs with \lstProperty{'subdivisions':2} and \lstProperty{'subdivisions-unit':1month 00:00:00}
    \item we have 10 jobs with \lstProperty{'subdivisions':4} and \lstProperty{'subdivisions-unit':1month 00:00:00}
    \item we have 10 jobs with \lstProperty{'subdivisions':8} and \lstProperty{'subdivisions-unit':1month 00:00:00}
  \end{itemize}
  \item From line 14 we have:
  \begin{itemize}
    \item an additional 30 jobs with:
    \begin{itemize}
      \item we have 10 jobs with \lstProperty{'subdivisions':2} and \lstProperty{'subdivisions-unit':7days 00:00:00}
      \item we have 10 jobs with \lstProperty{'subdivisions':4} and \lstProperty{'subdivisions-unit':7days 00:00:00}
      \item we have 10 jobs with \lstProperty{'subdivisions':8} and \lstProperty{'subdivisions-unit':7days 00:00:00}
    \end{itemize}
    \item an additional 30 jobs with:
    \begin{itemize}
      \item we have 10 jobs with \lstProperty{'subdivisions':2} and \lstProperty{'subdivisions-unit':14days 00:00:00}
      \item we have 10 jobs with \lstProperty{'subdivisions':4} and \lstProperty{'subdivisions-unit':14days 00:00:00}
      \item we have 10 jobs with \lstProperty{'subdivisions':8} and \lstProperty{'subdivisions-unit':14days 00:00:00}
    \end{itemize}
    \item an additional 30 jobs with:
    \begin{itemize}
      \item we have 10 jobs with \lstProperty{'subdivisions':2} and \lstProperty{'subdivisions-unit':21days 00:00:00}
      \item we have 10 jobs with \lstProperty{'subdivisions':4} and \lstProperty{'subdivisions-unit':21days 00:00:00}
      \item we have 10 jobs with \lstProperty{'subdivisions':8} and \lstProperty{'subdivisions-unit':21days 00:00:00}
    \end{itemize}
  \end{itemize}
\end{itemize}
Now imagine we had \lstProperty{'{1} time':'[1,2,3]:[00]:[00]} on line 15.
This is fine because the largest expansion of multiplier grouping '1' is 3. It would do the following:
\begin{itemize}
  \item To start we have:
  \begin{itemize}
    \item we have 10 jobs with \lstProperty{'subdivisions':2} and \lstProperty{'subdivisions-unit':1month 00:00:00} and \lstProperty{'time': 09:00:00}
    \item we have 10 jobs with \lstProperty{'subdivisions':4} and \lstProperty{'subdivisions-unit':1month 00:00:00} and \lstProperty{'time': 09:00:00}
    \item we have 10 jobs with \lstProperty{'subdivisions':8} and \lstProperty{'subdivisions-unit':1month 00:00:00} and \lstProperty{'time': 09:00:00}
  \end{itemize}
  \item From line 14 we have:
  \begin{itemize}
    \item an additional 30 jobs with:
    \begin{itemize}
      \item we have 10 jobs with \lstProperty{'subdivisions':2} and \lstProperty{'subdivisions-unit':7days 00:00:00} and \lstProperty{'time': 01:00:00}
      \item we have 10 jobs with \lstProperty{'subdivisions':4} and \lstProperty{'subdivisions-unit':7days 00:00:00} and \lstProperty{'time': 02:00:00}
      \item we have 10 jobs with \lstProperty{'subdivisions':8} and \lstProperty{'subdivisions-unit':7days 00:00:00} and \lstProperty{'time': 03:00:00}
    \end{itemize}
    \item an additional 30 jobs with:
    \begin{itemize}
      \item we have 10 jobs with \lstProperty{'subdivisions':2} and \lstProperty{'subdivisions-unit':14days 00:00:00} and \lstProperty{'time': 01:00:00}
      \item we have 10 jobs with \lstProperty{'subdivisions':4} and \lstProperty{'subdivisions-unit':14days 00:00:00} and \lstProperty{'time': 02:00:00}
      \item we have 10 jobs with \lstProperty{'subdivisions':8} and \lstProperty{'subdivisions-unit':14days 00:00:00} and \lstProperty{'time': 03:00:00}
    \end{itemize}
    \item an additional 30 jobs with:
    \begin{itemize}
      \item we have 10 jobs with \lstProperty{'subdivisions':2} and \lstProperty{'subdivisions-unit':21days 00:00:00} and \lstProperty{'time': 01:00:00}
      \item we have 10 jobs with \lstProperty{'subdivisions':4} and \lstProperty{'subdivisions-unit':21days 00:00:00} and \lstProperty{'time': 02:00:00}
      \item we have 10 jobs with \lstProperty{'subdivisions':8} and \lstProperty{'subdivisions-unit':21days 00:00:00} and \lstProperty{'time': 03:00:00}
    \end{itemize}
  \end{itemize}
\end{itemize}

So you'll notice having another property with grouping '1' will not multiply the amount of jobs more than what the multiplier already does.
So at this point we have 120 jobs.  If we add another multiplier grouping the property to multiplier '2' then it will multiply those properties to what is there,
just like what multiplier '1' did after the base.

\textbf{\large{'non-multiplier groupings'}}\\

So now we will discuss 'before-the-base' and 'after-the-base'.  Let's queue up the config file again.
\input{reservation_sweep.tex}

Let's continue from the example we were using.  If you had all the 120 jobs but you wanted to just add
one job to the mix you could decide if you want that job being run \textbf{before} or \textbf{after} the other 120 jobs.
Making a non-multiplier with a '-' would put the job \textbf{before} the 120 jobs. If you use a '-1' then all properties with -1 will be applied to the 1 job before
the 120.  If you want another job even before that, then group those properties with a '-2'.

The same logic is used for putting the job \textbf{after} the 120 jobs.  If you make a job group with '+1', then it will come after
the 120 jobs.  If you want to have another job come after that one, then use '+2' to group the properties.

And that is the completion of the reservations explanation.

\section{Command Reference}
\subsection{Batsim Environment}
\begin{termESC}
+?{prompt}+ cd ./simulator/basefiles
+?{prompt}+ source batsim_environment.sh
(batsim_env) +?{prompt}+
\end{termESC}
\subsubsection{batEnv}
\begin{termESC}
(batsim_env) +?{prompt}+ batEnv
/path/to/simulator
\end{termESC}
\subsubsection{batVersion}
\begin{termESC}
(batsim_env) +?{prompt}+ batVersion
1.0.6
\end{termESC}
\subsubsection{batExit}
\begin{termESC}
(batsim_env) +?{prompt}+ batExit
+?{prompt}+
\end{termESC}
\subsubsection{batFile}
\begin{termESC}
(batsim_env) +?{prompt}+batFile --help

batFile                     batFile can be invoked after sourcing 
                            $prefix/basefiles/batsim_environment.sh
It will help you choose a config file in your $prefix/configs and set it to file1
It will also help with setting folder1

Usage:
batFile [-NF] [ls options]

  -NF                     No Folder, will not ask you for a folder after asking 
                          for the file

  -[ls options]           Normally 'ls' is invoked to read your $prefix/configs
                          folder without any options.
                          You may find it helpful to use options to 'ls' such as: sort by 
                          time, reverse etc...
                          Just pass the ls options you would normally want to use to
                          batFile and you should be fine.  
                          I suggest using batFile like so:
                          batFile -ltr
-------------------------------------------------------------------------------------
post-running              After running this script you will see the last myBatchTasks
                          command you entered
                          It checks your ~/.bash_history file for this.  If all that shows
                          up is:
                          "myBatchTasks -f ${file1} -o ${folder1} "
                          Then you may need to flush your history with "history -w"
                          I leave this to the user as you may not want this flushed
\end{termESC}
\begin{termESC}
(bat_env) +?{prompt}+batFile -ltr  #newest configs on the bottom
  1  total 100
  2  -rw-r--r-- 1 user users  1254 Jul 21  2023 my_long_named_config.config
  3  -rw-r--r-- 1 user users  3369 Jul 31  2023 my_other_long_named_config.config
  4  -rw-r--r-- 1 user users  2651 Aug  4  2023 MTTR_from_2h_to_4h_step_0.5.config
Enter a choice (0 to exit): 2
Use a dot to exit: folder1 = my_long_named_config
file1=my_long_named_config.config
(bat_env) +?{prompt}+myBatchTasks.sh -f ${file1} -o ${folder1} -m bare-metal -p tasks -t 7

\end{termESC}
\subsubsection{batFolder}
\begin{termESC}
(bat_env) +?{prompt}+batFolder --help
batFolder                 batFolder can be invoked after sourcing 
                          $prefix/basefiles/batsim_environment.sh
                          It will help you choose a folder in your 
                          $prefix/experiments and set it to folder1
Usage:
batFolder [-#] [-i <path | -d <bookmark>] [ls options]

  -#                      Normally sets the chosen folder to folder1 but you can choose
                          folder1-folder9 with -1,-2,...,-9 flag

  -i <path>               Normally $prefix/experiments is used, but if you have another
                          folder to use set it here. Relative paths are not recommended.

  -d <bookmark>           If using dirB  will use the bookmark specified as the folder
                          *tab-completion works with this option

  -[ls options]           Normally 'ls' is invoked to read your $prefix/experiments 
                          folder without any options.  You may find it helpful to use
                          options to 'ls' such as: sort by time, reverse etc...
                          Just pass the ls options you would normally want to use to
                          batFolder and you should be fine. I suggest using batFolder
                          like so:
                          batFolder -ltr
\end{termESC}
\begin{termESC}
(bat_env) +?{prompt}+batFolder -3 -ltr    #newest folders on the bottom
                                       #value goes in $folder3 with -3 option
0
  1  drwxrwxr-x 1 craig users  210 Sep 14  2023 SMTBF_from_200k_to_300k_step_10k
  2  drwxrwxr-x 1 craig users  134 Oct 18  2023 October_Projects
  3  drwxrwxr-x 1 craig users  134 Oct 18  2023 test_synth_200
  4  drwxrwxr-x 1 craig users  134 Oct 23  2023 test_synth_5hr
Prepend selection with a '.' (period) to enter directory
Enter a choice (0 to exit):.2  # the folders that follow will not have -ltr 
                               # applied to them
-i /path/to/simulator/experiments/October_Projects
  1 SMTBF_from_200k_to_500k_step_50k
  2 test_synth_800
  3 test_synth_10hr
Prepend selection with a '.' (period) to enter directory
Enter a choice (0 to exit): 1
(batsim_env) +?{prompt}+echo $folder3
/path/to/simulator/experiments/October_Projects/SMTBF_from_200k_to_500k_step_50k

\end{termESC}
\subsubsection{bind\_all}
\begin{terminal}
(batsim_env) @|\prompt@|bind_all --help
        binds the following:
            alt+u:  previous-history
            alt+m:  next-history
            alt+y:  history-search-backward
            alt+n:  history-search-forward
            alt+j:  backward-char
            alt+k:  forward-char
            alt+h:  unix-line-discard
            alt+l:  beginning-of-line
            alt+;:  end-of-line
            alt+p:  yank
            alt+g:  kill-line

        **Note: Will only last while the shell is open for your user
                If you like these binds you can make them permanent for your shell by
                editing ~/$USER/.bashrc
                and adding the following to that file:
                                
                function bind_keys
                {
                    bind '"\eu":previous-history'
                    bind '"\em":next-history'
                    bind '"\ey":history-search-backward'
                    bind '"\en":history-search-forward'
                    bind '"\ej":backward-char'
                    bind '"\ek":forward-char'
                    bind '"\eh":unix-line-discard'
                    bind '"\el":beginning-of-line'
                    bind '"\e;":end-of-line'
                    bind '"\ep":yank'
                    bind '"\eg":kill-line'
                }
                #this determines whether we are in an interactive shell, 
                #the only time the commands are usable.  It will bind if it is.
                #if unusable the bind command will print out error messages and gets 
                #in the way.  So it is best to check.
                STR="$-";SUB="i";INTERACTIVE=0
                if [[ "$STR" == *"$SUB"* ]]; then
                    INTERACTIVE=1
                    bind_keys
                fi
\end{terminal}
\subsection{myBatchTasks.sh}
\begin{termPESC}

myBatchTasks.sh -         automates the generate-config script and run-experiments
                          script. Meant to be run from the command line and probably
                          put into the background.  
                          NOTE: make sure you are in a batsim_environment and the
                          correct one.

Usage:
myBatchTasks.sh -f <STR> -o <STR> (-p sbatch [-c <INT>] | -p tasks -t <INT> )[-m <STR>] 
                [-s <INT>] [-w <STR>][--permissions <STR>][--start-from-checkpoint <INT>]

Required Options:

-f, --file <STR>          The config file.  Just the file name, the folder of where that
                          file is is worked out from $PREFIX being set and default 
                          locations within

-o, --folder  <STR>       Where to output all the results of the simulations.  Just the
                          folder name of where to put stuff within the default locations
                          ( $PREFIX/experiments/<folder_name>)

-t, --tasks-per-node <INT>  How many tasks to put on each node
                            Only used with --parallel-method 'tasks' and 'background'
                            and mandatory with these parallel-methods

Optional Options:
-a, --add-to-sbatch <STR>   Commands to add to sbatch, in the form:
                            long:
                              -a "--option_s value --option_t value --option_u --option"
                            short/mixed:
                              --add-to-sbatch "-s value -t value -u --option"

-c, --cores-per-node <INT>  How many cores to use for each sbatch
                            Only used with --parallel-method 'sbatch'
                            Not mandatory

-m, --method <STR>          What method to run batsim:
                            'bare-metal' | 'docker' | 'charliecloud'
                            [default: 'bare-metal']

-p, --parallel-method <STR> What method to spawn multiple batsims:
                            'sbatch' | 'tasks' | 'none' | 'background'
                            sbatch: individual sbatch commands for each sim
                            tasks: --tasks-per-node sims per sbatch command, with enough
                              sbatch's to complete config file generated sims
                            none: no parallelism,only serial. Will run one sim after
                              another (may take a VERY long time)
                            background: will try to achieve parallelism by backgrounding
                              each sim, backgrounding (--tasks-per-node - 1) sims
                              before waiting
                            [default: 'tasks']

-s, --socket-start <INT>    What socket number to start at. You must do your own
                            housekeeping of sockets.  If you already have 100 sims
                            going and you started at 10,000, then you will want to do
                            your next set of sims at 10,100 for example.
                            You can use higher numbers.  I've used numbers up to 300,000
                            [default: 10000]

-w, --wallclock-limit <STR> How long your jobs will take as reported to SLURM
                            Will leave it up to slurm if not chosen.  Sometimes SLURM 
                            will set it for UNLIMITED
                            STR is in format:
                            "minutes", "minutes:seconds", "hours:minutes:seconds", 
                            "days-hours", "days-hours:minutes" and 
                            "days-hours:minutes:seconds"
                            ex: '48' , '48:30', '2:48:30'     
                                  = 48 minutes, 48.5 minutes, 2hours 48.5 minutes
                            ex: '3-0' , '3-12:0', '3-12:30:0'
                                  = 3days, 3days 12 hours, 3 days 12.5 hours
              
-P, --permissions <STR>     permissions to give files/folders after generate_config.py is
                            run but before run-experiments.py is run. It is still suggested
                            to use SLURM_UMASK in batsim_environment.sh for files made
                            during the simulations.
                            STR = The octal numbers for the permissions
                            ex: '--permissions 777' = rwxrwxrwx
                                '--permissions 750' = rwxr-x---
                                '--permissions 755' = rwxr-xr-x

--test-suite                set this flag to create current_progress.log in one folder
                            up from FOLDER1

-C, --skip-completed-sims   Set this to skip sims that are in progress.log as completed
                            [default: false]
Checkpoint Batsim Options:

-S, --start-from-checkpoint <INT>   Set this if starting from a checkpoint.  The 
                                    <INT> is the number of the checkpoint.
                                    Typically '1', the latest
                                    [default: false]

-D, --discard-last-frame            Used in conjunction with --start-from-checkpoint 
                                    and can be used with --start-from-frame
                                    Does not make sense to use with 
                                    --start-from-checkpoint-keep
                                    Flag to give the following behavior:
                                      Will not change any of the kept expe-out_#'s and
                                      Will not keep the current expe-out

-K, --start-from-checkpoint-keep <INT>  Used in conjunction with --start-from-checkpoint
                                        Will keep expe-out_1 through exp-out_<INT>.  
                                        Only use with --start-from-checkpoint
                                        When starting from checkpoint, the current 
                                        expe-out folder becomes expe-out_1.
                                        Previous expe-out_1 will become expe-out_2 if 
                                        keep is set to 2
                                        If you have expe-out_1,expe-out_2,expe-out_3 and
                                        keep is 3:
                                          will move expe-out_1 to expe-out_2
                                          will move expe-out_2 to expe-out_3
                                          will delete old expe-out_3
                                        [default: 1]

-F, --start-from-frame <INT>          Only used with --start-from-checkpoint and in 
                                      conjunction with --start-from-checkpoint-keep
                                      Will use the expe-out_<INT> folder to look for
                                      the checkpoint data. So if you were invoking
                                      --start-from-checkpoint-keep 2,
                                      you would have expe-out_1 and expe-out_2,   
                                      once you started from a checkpoint twice
                                      If you use --start-from-frame 2 you will be using
                                      the checkpoint_[--start-from-checkpoint]
                                      folder located in the expe-out_2 folder 
                                      ( the expe-out_[--start-from-frame] folder)
                                      Here, '0' is the original expe-out folder that 
                                      becomes expe-out_1
                                      If --discard-last-frame is used, then default here
                                      is 1. 0 is not allowed and will become 1 if used.
                                      [default: 0]

-I, --ignore-does-not-exist           Normally if the path to one of the checkpoints
                                      does not exist it will ERROR out and stop.
                                      This option tells it that some paths may not exist, 
                                      but run the others that do,
                                      and not to alter anything in the paths that do not
                                      exist.

-h, --help                            Display this usage page
\end{termPESC}
\subsection{progress.sh}
\begin{termPESC}
progress.sh: used to show the progress of all simulations in a folder, or just certain 
             ones, with options for what to show.

Usage:
  progress.sh [-# | -i <folder> | -d <bookmark> ] [-P <options>] [-e <folder>] 
              [-j <array string>] [-D <array string>] [-r <array string>]
              [-b <int>] [-H] [-p] [-c] [-q] [-s] 
              [-m <batsim|batsched|both|all|available>] [-M K|M|G|T|H]

Mostly Required Options:

-#              Will use the environment variable folder# for input.  
                It will act as if you used -i ${folder#}
                This is best used in conjunction with batFolder
                NOTE: using this method requires folder# to be exported: export folder#
                NOTE: batFolder automatically exports the corresponding folder# variable
                          
-d <bookmark>           Will use the dibB.sh bookmark
                                  
-i, --input <folder>    Where the experiments are.  This is supposed to be the outer 
                        folder passed to ./myBatchTasks.sh
                        If it has a forward slash '/' in the name it will assume it 
                        is an absolute path.
                        If it does not have a forward slash '/' in the name it will 
                        assume it is located in "$prefix/experiments/<input>"
                        If --prompt is used, this folder is interpreted as where to look 
                        for experiment directories.
                        If --prompt is used and this option is omitted, the default will 
                        be used '${prefix}/experiments'

Optional Options:

Folder Options:
  -P, --prompt <options>    Another option instead of setting input directly
                            Will go into folder '--input <folder>' and list the 
                            directories for you.  Select the folder you are after
                            with a number. If --input is omitted, will use 
                            '${prefix}/experiments'
                            The options you want to send ls comes after prompt, but use 
                            quotes around the whole list of options as to not confuse 
                            this script.
                            Make sure you use empty quotes if not setting any options
                            Also look into using batFolder for repeated uses of 
                            progress.sh
                            example:    progress.sh -P '-ltr'    or      
                                        progress.sh -i "/some/other/path" -P ''

  --up                      Normally if you pass --input as a Run_#,output,or expe-out 
                            folder you will get a single progress of that folder's 
                            simulation. With this option, it will always set the 
                            corresponding project folder as the input.  
                            Must appear after -i option

Which-Simulation Options:

  -e, --experiment <folder>     If you want to focus on just one experiment (in the sense 
                                of config files where there was an input and output json
                                for each experiment) then use this to enter the folder.
                                The path retrieved will then be 
                                ".../<input>/<experiment>/*"
                                <folder> can include wildcard (*) characters as well. 
                                For instance...
                                  progress.sh -i ${folder1} -e "*shuffled*"
                                if you were going to shuffle some experiments and named 
                                those experiments with 'shuffled' in the name,
                                then this would get you all the experiments with the word 
                                'shuffled' in it.

  -j, --job <array string>       If you want to focus on just one job (in the sense of 
                                 folders named experiment_#) then use this to enter the 
                                 folder number.  
                                 If used with --experiment then it will retrieve paths
                                 ".../<input>/<experiment>/experiment_<job>/*
                                 If not used with --experiment, then it will retrieve 
                                 paths ".../<input>/*/experiment_<job>/*
                                 If multiple jobs are wanted then put the job numbers 
                                 into a string, 
                                 for example: '-j "1 2-5 10"'  
                                   will gather experiment_1,experiment_2,
                                   experiment_3,experiment_4,experiment_5, and 
                                   experiment_10
                                 for example: '-j "3:1000:50 1 1050-1055"'
                                   will gather '3-1000 step of 50' '1' and
                                   '1050,1051,1052,1053,1054,1055'

  -D, --id <array string>        If you want to focus on just one id (in the sense of 
                                 folders named id_#) then use this to enter the folder 
                                 number. Basically the same as --job as far as how it
                                 works, except we focus on the id(s)
                                 Look at --job for string format

  -r, --run <array string>       If you want to focus on just one run (in the sense of 
                                 folders named Run_#) then use this to enter the folder
                                 number. Basically the same as --job and --id as far as 
                                 how it works, except we focus on the run(s)
                                 Look at --job for string format

  -F, --finished-sims            Only include sims that have:
                                 overall_completed_jobs == overall_jobs

  -U, --unfinished-sims          Only include sims that have:
                                 overall_completed_jobs !\notsign!= overall_jobs

  -T, --threshold <string>       Only include sims that are above or below a threshold 
                                 for overall_percent_done
                                 format of string: "(+|-) <threshold float>"

What-Info Options:

  -b, --before <int>             The amount of entries, starting from the last one, to 
                                 include

  -H, --head                     Print the first entry in the out_extra_info.csv file 
                                 first ( possible use is to check on how long the sim 
                                 has been going )

  -a, --all                      Print out all data in the entry.  Default if nothing 
                                 else is chosen to print.

  -E, --elapsed-time             Prints out the real elapsed time of the simulation.  
                                 Must include the option to see it.
                                 Not included in the --all option, but keeps --all the
                                 default.
                                 Use -z "a" option to supress all, or choose what else
                                 to print out.

  -o, --overall-percent          Prints out the overall-percent when used with 
                                 checkpoints.  Must include the option to see it.
                                 Not included in the --all option, but keeps --all the
                                 default.
                                 Use -z "a" option to supress all, or choose what else
                                 to print out.

  -O, --original-info            Prints out "overall-percent, original-jobs,
                                 number-resubmits,total-actually-completed"
                                 Not included in the --all option, but keeps --all the
                                 default.
                                 Use -z "a" option to supress all, or choose what else
                                 to print out.

  -p, --percent                  Include the percentage done that the sim has done

  -c, --completed                Include the amount of ACTUALLY completed jobs and 
                                 TOTAL jobs

  -t, --time                     Include the real-time and sim-time

  -S, --schedule-info            Include queue-size,schedule-size,nb-jobs-running

  -q, --queue-size               Include the queue-size in output

  -s, --schedule-size            Include the schedule-size in output

  -u, --utilization              Include utilization and utilization-without-reservations

  -m, --memory <string>          Include the memory usage.  Will include the USS,PSS,RSS
                                 for "batsim|batsched|both".  
                                 Other options are "all|available"

  -M, --memory-size <string>     When displaying memory, what size to display: 
                                 KB | MB | GB | TB | H.  
                                 Single letter is fine too: K | M | G | T | H
                                 This will actually be in KiB, MiB, GiB, or TiB
                                 H signifies you want human-readable units.  
                                 This is the largest unit that makes sense for the data.
                                 [default: H]
  -z, --no-info <string>         What categories NOT to show.<string> is a comma seperated 
                                 string with all of the short options above
                                 but instead of displaying what the options would normally 
                                 select, it displays everything except them.
                                 ex: "t m" no time, no memory, everything else
                                 ex: "a" nothing else except what is selected 
                                     (in particular, use "a" with -O and -o options)

  -N, --normal-info              Prints a normal usage scenario: -O -E -c -p -Z
Presentation Options
  -C, --condensed                When displaying data, will not follow the line breaks of
                                 the "format" at the bottom

  -Z, --super-condensed          When displaying format at the bottom, will use 
                                 abbreviated names
                                 When displaying data, will not follow the line breaks of
                                 the "format" string
                                 When displaying path, will use a condensed version of it

  -h, --help                     Display this usage page
\end{termPESC}
\subsection{aggregate\_makespan.py}
\begin{termPESC}
Usage:
  aggregate-makespan.py -i FOLDER [--output FOLDER] [--try-frame1] [--start-run INT] 
                        [--end-run INT] [--bins]

Required Options:
  -i FOLDER --input FOLDER    where the experiments are

Options:
  -o FOLDER --output FOLDER   where the output should go
                              [default: input]

  -t --try-frame1             if we don't find makespan.csv in normal expe-out, 
                              then try expe-out_1

  --start-run INT             only include runs starting at start-run
                           
  --end-run INT               only include runs ending at and including end-run

  --bins                      TODO If set, will calculate from binned data
                              This assumes you have run post-processing with bins 
                              located in output/config.ini
                              and that it produced output/expe-out/bins/*.csv files
\end{termPESC}



\end{document}
